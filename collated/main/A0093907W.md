# A0093907W
###### /java/seedu/todo/controllers/AddController.java
``` java
 */
public class AddController implements Controller {
    
    private static final String NAME = "Add";
    private static final String DESCRIPTION = "Adds a task / event to the to-do list.\n"
                                            + "Accepts natural date formats (e.g. \"Today 5pm\" is allowed).";
    private static final String COMMAND_SYNTAX = "add <task> by <deadline> || add <event> from <start_date> to <end_date>";
    
    private static final String MESSAGE_ADD_SUCCESS = "Item successfully added!";
    
    private static CommandDefinition commandDefinition =
            new CommandDefinition(NAME, DESCRIPTION, COMMAND_SYNTAX); 

    public static CommandDefinition getCommandDefinition() {
        return commandDefinition;
    }

    @Override
    public float inputConfidence(String input) {
        // TODO
        return (input.toLowerCase().startsWith("add")) ? 1 : 0;
    }
    
    /**
     * Get the token definitions for use with <code>tokenizer</code>.<br>
     * This method exists primarily because Java does not support HashMap
     * literals...
     * 
     * @return tokenDefinitions
     */
    private static Map<String, String[]> getTokenDefinitions() {
        Map<String, String[]> tokenDefinitions = new HashMap<String, String[]>();
        tokenDefinitions.put("default", new String[] {"add"});
        tokenDefinitions.put("eventType", new String[] { "event", "task" });
        tokenDefinitions.put("time", new String[] { "at", "by", "on", "before", "time" });
        tokenDefinitions.put("timeFrom", new String[] { "from" });
        tokenDefinitions.put("timeTo", new String[] { "to" });
        return tokenDefinitions;
    }

    @Override
    public void process(String input) throws ParseException {
        
        Map<String, String[]> parsedResult;
        parsedResult = Tokenizer.tokenize(getTokenDefinitions(), input);
        
        // Task or event?
        boolean isTask = parseIsTask(parsedResult);
        
        // Name
        String name = parseName(parsedResult);
        
        // Time
        String[] naturalDates = parseDates(parsedResult);
        String naturalFrom = naturalDates[0];
        String naturalTo = naturalDates[1];
        
        // Validate isTask, name and times.
        if (validateParams(isTask, name, naturalFrom, naturalTo)) {
            renderDisambiguation(isTask, name, naturalFrom, naturalTo);
            return;
        }
        
        // Parse natural date using Natty.
        LocalDateTime dateFrom;
        LocalDateTime dateTo;
        try {
            dateFrom = naturalFrom == null ? null : parseNatural(naturalFrom);
            dateTo = naturalTo == null ? null : parseNatural(naturalTo);
        } catch (InvalidNaturalDateException e) {
            renderDisambiguation(isTask, name, naturalFrom, naturalTo);
            return;
        }
        
        // Create and persist task / event.
        TodoListDB db = TodoListDB.getInstance();
        createCalendarItem(db, isTask, name, dateFrom, dateTo);
        
        // Re-render
        Renderer.renderIndex(db, MESSAGE_ADD_SUCCESS);
    }

    /**
     * Creates and persists a CalendarItem to the DB.
     * 
     * @param db
     *            TodoListDB object
     * @param isTask
     *            true if CalendarItem should be a Task, false if Event
     * @param name
     *            Display name of CalendarItem object
     * @param dateFrom
     *            Due date for Task or start date for Event
     * @param dateTo
     *            End date for Event
     */
    private void createCalendarItem(TodoListDB db, 
            boolean isTask, String name, LocalDateTime dateFrom, LocalDateTime dateTo) {
        if (isTask) {
            Task newTask = db.createTask();
            newTask.setName(name);
            newTask.setDueDate(dateFrom);
        } else {
            Event newEvent = db.createEvent();
            newEvent.setName(name);
            newEvent.setStartDate(dateFrom);
            newEvent.setEndDate(dateTo);
        }
        db.save();
    }

    
    /**
     * Validates the parsed parameters.
     * 
     * <ul>
     * <li>Fail if name is null.</li>
     * <li>Fail if "to" exists without "from"</li>
     * <li>Fail if task, but "from" and "to" exist</li>
     * </ul>
     * 
     * @param isTask
     *            true if CalendarItem should be a Task, false if Event
     * @param name
     *            Display name of CalendarItem object
     * @param naturalFrom
     *            Raw input for due date for Task or start date for Event
     * @param naturalTo
     *            Raw input for end date for Event
     * @return true if validation passed, false otherwise
     */
    private boolean validateParams(boolean isTask, String name, String naturalFrom, String naturalTo) {
        return (name == null ||
                (naturalFrom == null && naturalTo != null) || (isTask && naturalTo != null));
    }
    
    /**
     * Extracts the natural dates from parsedResult.
     * 
     * @param parsedResult
     * @return { naturalFrom, naturalTo }
     */
    private String[] parseDates(Map<String, String[]> parsedResult) {
        String naturalFrom = null;
        String naturalTo = null;
        setTime: {
            if (parsedResult.get("time") != null && parsedResult.get("time")[1] != null) {
                naturalFrom = parsedResult.get("time")[1];
                break setTime;
            }
            if (parsedResult.get("timeFrom") != null && parsedResult.get("timeFrom")[1] != null) {
                naturalFrom = parsedResult.get("timeFrom")[1];
            }
            if (parsedResult.get("timeTo") != null && parsedResult.get("timeTo")[1] != null) {
                naturalTo = parsedResult.get("timeTo")[1];
            }
        }
        return new String[] { naturalFrom, naturalTo };
    }

    /**
     * Extracts the display name of the CalendarItem from parsedResult.
     * 
     * @param parsedResult
     * @return name
     */
    private String parseName(Map<String, String[]> parsedResult) {
        String name = null;
        if (parsedResult.get("default") != null && parsedResult.get("default")[1] != null) {
            name = parsedResult.get("default")[1];
        }
        if (parsedResult.get("eventType") != null && parsedResult.get("eventType")[1] != null) {
            name = parsedResult.get("eventType")[1];
        }
        return name;
    }

    /**
     * Extracts the intended CalendarItem type from parsedResult.
     * 
     * @param parsedResult
     * @return true if Task, false if Event
     */
    private boolean parseIsTask(Map<String, String[]> parsedResult) {
        boolean isTask = true;
        if (parsedResult.get("eventType") != null && parsedResult.get("eventType")[0].equals("event")) {
            isTask = false;
        }
        return isTask;
    }

    /**
     * Parse a natural date into a LocalDateTime object.
     * 
     * @param natural
     * @return LocalDateTime object
     * @throws InvalidNaturalDateException 
     */
    private LocalDateTime parseNatural(String natural) throws InvalidNaturalDateException {
        Parser parser = new Parser();
        List<DateGroup> groups = parser.parse(natural);
        Date date = null;
        try {
            date = groups.get(0).getDates().get(0);
        } catch (IndexOutOfBoundsException e) {
            throw new InvalidNaturalDateException(natural);
        }
        LocalDateTime ldt = LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());
        return ldt;
    }
    
    private void renderDisambiguation(boolean isTask, String name, String naturalFrom, String naturalTo) {
        name = StringUtil.replaceEmpty(name, "<name>");
        naturalTo = StringUtil.replaceEmpty(name, "<end time>");

        String disambiguationString;
        String errorMessage = ""; // TODO
        
        if (isTask) {
            naturalFrom = StringUtil.replaceEmpty(naturalFrom, "<deadline>");
            disambiguationString = String.format("add task \"%s\" by \"%s\"", name, naturalFrom);
        } else {
            naturalFrom = StringUtil.replaceEmpty(naturalFrom, "<start time>");
            naturalTo = StringUtil.replaceEmpty(naturalTo, "<end time>");
            disambiguationString = String.format("add event \"%s\" from \"%s\" to \"%s\"", name, naturalFrom, naturalTo);
        }
        
        // Show an error in the console
        Renderer.renderDisambiguation(disambiguationString, errorMessage);
    }
    
}
```
###### /java/seedu/todo/controllers/AliasController.java
``` java
 */
public class AliasController implements Controller {
    
    private static final String NAME = "Alias";
    private static final String DESCRIPTION = "Shows current aliases or updates them.";
    private static final String COMMAND_SYNTAX = "alias [<alias key> <alias value>]";
    
    private static final String SPACE = " ";
    private static final int ARGS_LENGTH = 2;
    private static final String MESSAGE_SHOWING = "Showing all aliases.";
    private static final String MESSAGE_SAVE_SUCCESS = "Successfully saved alias!";
    private static final String INVALID_NUM_PARAMS = "Seems like you have provided an invalid number of parameters!";
    private static final String MESSAGE_INVALID_INPUT = "Invalid alias parameters! Alias inputs must consist solely "
                                                      + "of alphabetical characters.";
    private static final String SAVE_ERROR = "There was an error saving your aliases. Please try again.";
    
    private static CommandDefinition commandDefinition =
            new CommandDefinition(NAME, DESCRIPTION, COMMAND_SYNTAX); 

    public static CommandDefinition getCommandDefinition() {
        return commandDefinition;
    }
    
    @Override
    public float inputConfidence(String input) {
        // TODO
        return input.toLowerCase().startsWith("alias") ? 1 : 0;
    }

    @Override
    public void process(String input) {
        String params = input.replaceFirst("alias", "").trim();

        if (params.length() <= 0) {
            Renderer.renderAlias(MESSAGE_SHOWING);
            return;
        }
        
        String[] args = params.split(SPACE, ARGS_LENGTH);
        
        String aliasKey = null;
        String aliasValue = null;
        
        // Best-effort matching, disambiguate if wrong.
        validate: {
            switch (args.length) {
                case 0:
                    break;
                case 1:
                    aliasKey = args[0];
                    break;
                case 2: // All good!
                    aliasKey = args[0];
                    aliasValue = args[1];
                    break validate;
                default:
                    aliasKey = args[0];
                    aliasValue = args[0];
                    break;
            }
            renderDisambiguation(aliasKey, aliasValue, INVALID_NUM_PARAMS);
            return;
        }
        
        if (!validateAlias(aliasKey) || !validateAlias(aliasValue)) {
            renderDisambiguation(aliasKey, aliasValue, MESSAGE_INVALID_INPUT);
            return;
        }
        
        // Persist alias mapping
        try {
            saveAlias(aliasKey, aliasValue);
        } catch (IOException e) {
            Renderer.renderAlias(SAVE_ERROR);
            return;
        }
        
        Renderer.renderAlias(MESSAGE_SAVE_SUCCESS);
    }
    
    /**
     * Persists an alias mapping to the database.
     * 
     * @param db    TodoListDB singleton
     * @param aliasKey
     * @param aliasValue
     * @throws IOException 
     */
    private static void saveAlias(String aliasKey, String aliasValue) throws IOException {
        Config config = MainApp.getConfig();
        Map<String, String> aliases = config.getAliases();
        aliases.put(aliasKey, aliasValue);
        ConfigUtil.saveConfig(config, MainApp.getConfigFilePath());
        
    }
    
    /**
     * Validates that string is sanitized and safe for aliasing.
     * 
     * @param alias     string to check
     * @return          true if string is sanitized, false otherwise
     */
    private static boolean validateAlias(String alias) {
        return alias.chars().allMatch(Character::isLetter);
    }
    
    private static void renderDisambiguation(String aliasKey, String aliasValue, String message) {
        String sanitizedAliasKey = StringUtil.sanitize(aliasKey);
        sanitizedAliasKey = StringUtil.replaceEmpty(sanitizedAliasKey, "<alias key>");
        String sanitizedAliasValue = StringUtil.sanitize(aliasValue);
        sanitizedAliasValue = StringUtil.replaceEmpty(sanitizedAliasValue, "<alias value>");
        Renderer.renderDisambiguation(String.format("alias %s %s",
                sanitizedAliasKey, sanitizedAliasValue), message);
    }

}
```
###### /java/seedu/todo/controllers/concerns/Renderer.java
``` java
 *
 */
public class Renderer {

    private static final String MESSAGE_DISAMBIGUATE = "Your last command wasn't clear, please fix your command and try again.";
    
    /**
     * Renders an error message in both the console and the input field, leave null or empty string if not needed.
     * @param replacedCommand    Value to display in the input field
     * @param detailedError       Message to be rendered in the console
     */
    public static void renderDisambiguation(String replacedCommand, String detailedError) {
        // Update console input field
        if (replacedCommand != null && replacedCommand.length() > 0) {
            UiManager.updateConsoleInputValue(replacedCommand);
        }
        
        // Update console message
        if (detailedError != null && detailedError.length() > 0) {
            UiManager.updateConsoleMessage(String.format("%s\n\n%s", MESSAGE_DISAMBIGUATE, detailedError));
        } else {
            UiManager.updateConsoleMessage(String.format("%s", MESSAGE_DISAMBIGUATE));
        }
    }
    
    /**
     * Renders the indexView.
     * 
     * @param db
     * @param consoleMessage to be rendered in console, leave null if not needed
     */
    public static void renderSelected(TodoListDB db, String consoleMessage, List<Task> tasks, List<Event> events) {
        IndexView view = UiManager.loadView(IndexView.class);
        
        if (tasks != null) {
            view.tasks = tasks;
        }
        
        if (events != null) {
            view.events = events;
        }
        view.tags = db.getTagList();
        UiManager.renderView(view);
        
        if (consoleMessage != null) {
            UiManager.updateConsoleMessage(consoleMessage);
        }
    }
    
    /**
     * Renders the indexView.
     * 
     * @param db
     * @param consoleMessage to be rendered in console, leave null if not needed
     */
    public static void renderIndex(TodoListDB db, String consoleMessage) {
        IndexView view = UiManager.loadView(IndexView.class);
        view.tasks = db.getIncompleteTasksAndTaskFromTodayDate();
        view.events = db.getAllCurrentEvents();
        view.tags = db.getTagList();
        UiManager.renderView(view);
        
        if (consoleMessage != null) {
            UiManager.updateConsoleMessage(consoleMessage);
        }
    }
    
    /**
     * Renders the ConfigView.
     * 
     * @param consoleMessage to be rendered in console, leave null if not needed
     */
    public static void renderConfig(String consoleMessage) {
        ConfigView view = UiManager.loadView(ConfigView.class);
        UiManager.renderView(view);
        
        if (consoleMessage != null) {
            UiManager.updateConsoleMessage(consoleMessage);
        }
    }
    
    public static void renderAlias(String consoleMessage) {
        AliasView view = UiManager.loadView(AliasView.class);
        UiManager.renderView(view);
        
        if (consoleMessage != null) {
            UiManager.updateConsoleMessage(consoleMessage);
        }
    }

}
```
###### /java/seedu/todo/controllers/concerns/Tokenizer.java
``` java
 */
public class Tokenizer {

    private static final String UNMATCHED_QUOTES_MESSAGE = "Unmatched double-quotes detected.";
    private final static String QUOTE = "\"";

    /**
     * A private class to tag a string as a token or a quote.
     * @author louietyj
     *
     */
    private static class TokenizedString {
        public String string;
        public boolean isToken;
        public boolean isQuote;

        TokenizedString(String string, boolean isToken, boolean isQuote) {
            this.string = string;
            this.isToken = isToken;
            this.isQuote = isQuote;
        }

        @Override
        public String toString() {
            return String.format("TokenizedString(%s, %s, %s)", this.string, isToken, isQuote);
        }
    }

    /**
     * Tokenizer method to parse a user-input string into a mapping of tokenType -> tokenField.
     * <ul>
     *   <li>Quoted chunks are kept as a whole and never matched to a token.</li>
     *   <li>If there are multiple token matches, only the first one will be registered.</li>
     *   <li>If there are multiple tokenType matches, only one match will be returned.</li>
     * </ul>
     * @param tokenDefinitions  Mapping of tokenType -> list of token strings to match
     * @param inputCommand      User input to tokenize
     * @return                  Mapping of tokenType -> { matchedToken, tokenField }
     * @throws UnmatchedQuotesException If there is an odd number of quotes
     */
    public static Map<String, String[]> tokenize(Map<String, String[]> tokenDefinitions, String inputCommand)
            throws UnmatchedQuotesException {
        
        // Generate token -> tokenType mapping and list of tokens
        List<String> tokens = new ArrayList<String>();
        HashMap<String, String> getTokenType = new HashMap<String, String>();
        for (Map.Entry<String, String[]> tokenDefinition : tokenDefinitions.entrySet()) {
            String tokenType = tokenDefinition.getKey();
            for (String token : tokenDefinition.getValue()) {
                tokens.add(token);
                getTokenType.put(token, tokenType);
            }
        }

        if (inputCommand.length() == 0) {
            return null;
        }

        // Split inputCommand into arraylist of chunks

        if (StringUtils.countMatches(inputCommand, QUOTE) % 2 == 1) {
            throw new UnmatchedQuotesException(UNMATCHED_QUOTES_MESSAGE);
        }

        // --- Split by quotes
        String[] splitString = inputCommand.split(QUOTE);

        // If first char is QUOTE, then first element is a quoted string.
        List<TokenizedString> tokenizedSplitString = new ArrayList<TokenizedString>();
        for (int i = 0; i < splitString.length; i++) {
            tokenizedSplitString.add(new TokenizedString(splitString[i].trim(), false, (i % 2 == 1)));
        }
        
        // --- Split by tokens
        Map<String, Integer> tokenIndices = splitByTokens(tokens, getTokenType, tokenizedSplitString);
        
        // Get arraylist of indices
        // Get dictionary of tokenType -> index
        // Return dictionary of tokenType -> {token, tokenField}
        return constructParsedResult(tokenizedSplitString, tokenIndices);
    }

    /**
     * Constructs the parsedResult from user input that has been delimited and tokenized.
     * @param tokenizedSplitString
     * @param tokenIndices
     * @return parsedResult
     */
    private static Map<String, String[]> constructParsedResult(List<TokenizedString> tokenizedSplitString,
            Map<String, Integer> tokenIndices) {
        Map<String, String[]> parsedResult = new HashMap<String, String[]>();
        for (Map.Entry<String, Integer> tokenIndex : tokenIndices.entrySet()) {
            String tokenType = tokenIndex.getKey();
            String token = tokenizedSplitString.get(tokenIndex.getValue()).string;
            String tokenField = null;
            // Should just EAFP instead of LBYL, but oh well.
            if (tokenIndex.getValue() + 1 < tokenizedSplitString.size() && !tokenizedSplitString.get(tokenIndex.getValue() + 1).isToken) {
                tokenField = tokenizedSplitString.get(tokenIndex.getValue() + 1).string;
            }
            parsedResult.put(tokenType, new String[] { token, tokenField });
        }
        return parsedResult;
    }

    /**
     * Re-implementation from scratch of
     * <code>tokens.split("token1|token2|token3|...")</code> with the constraint
     * that quoted strings are kept intact and unmatched.
     * 
     * @param tokens
     *            List of tokens to match
     * @param getTokenType
     *            Mapping of token -> tokenType
     * @param tokenizedSplitString
     *            User input with quoted strings tagged. This method will modify
     *            tokenizedSplitString in-place.
     * @return Indexes of matched tokens
     */
    private static Map<String, Integer> splitByTokens(List<String> tokens, HashMap<String, String> getTokenType,
            List<TokenizedString> tokenizedSplitString) {
        Map<String, Integer> tokenIndices = new HashMap<String, Integer>();
        for (int i = 0; i < tokenizedSplitString.size(); i++) { // Java doesn't eager-evaluate the terminating condition
            TokenizedString currString = tokenizedSplitString.get(i);
            if (currString.isQuote) {
                continue;
            }
            
            // Record token.
            if (currString.isToken) {
                tokenIndices.put(getTokenType.get(currString.string), i);
                tokens.remove(currString.string);
                continue;
            }
            
            // Try to match all the tokens
            for (String token : tokens) {
                Matcher m = Pattern.compile(String.format("\\b%s\\b", token), Pattern.CASE_INSENSITIVE)
                        .matcher(currString.string);
                if (!m.find()) {
                    continue;
                }
                
                // Found. Replace current element with split elements.
                String preString = currString.string.substring(0, m.start()).trim();
                String postString = currString.string.substring(m.end(), currString.string.length()).trim();
                
                tokenizedSplitString.remove(i);
                List<TokenizedString> replacedSplitStrings = new ArrayList<TokenizedString>();
                if (!preString.isEmpty()) {
                    replacedSplitStrings.add(new TokenizedString(preString, false, false));
                }
                replacedSplitStrings.add(new TokenizedString(token, true, false));
                if (!postString.isEmpty()) {
                    replacedSplitStrings.add(new TokenizedString(postString, false, false));
                }
                tokenizedSplitString.addAll(i, replacedSplitStrings);
                
                // Restart outer loop at current index.
                i--;
                break;
            }   
        }
        return tokenIndices;
    }

}

```
###### /java/seedu/todo/controllers/Controller.java
``` java
 *
 */
public interface Controller {
    
    /**
     * Given a user input, returns a measure of confidence of whether the input
     * should be processed by the controller.
     * 
     * @param input
     *            User input
     * @return confidence A float in the range [0, 1] where 1 means extremely
     *         confident.
     */
    public float inputConfidence(String input);
    
    /**
     * Processes the user input.
     * 
     * @param input
     *            User input
     */
    public void process(String input) throws ParseException;

}
```
###### /java/seedu/todo/controllers/RedoController.java
``` java
 */
public class RedoController implements Controller {
    
    private static final String MESSAGE_SUCCESS = "Successfully redid %s %s!\nTo undo, type \"undo\".";
    private static final String MESSAGE_MULTIPLE_FAILURE = "We cannot redo %s %s! At most, you can redo %s %s.";
    private static final String MESSAGE_FAILURE = "There is no command to redo!";

    @Override
    public float inputConfidence(String input) {
        return input.toLowerCase().startsWith("redo") ? 1 : 0;
    }
    
    /**
     * Get the token definitions for use with <code>tokenizer</code>.<br>
     * This method exists primarily because Java does not support HashMap
     * literals...
     * 
     * @return tokenDefinitions
     */
    private static Map<String, String[]> getTokenDefinitions() {
        Map<String, String[]> tokenDefinitions = new HashMap<String, String[]>();
        tokenDefinitions.put("default", new String[] {"redo"});
        return tokenDefinitions;
    }

    @Override
    public void process(String input) throws ParseException {
        
        Map<String, String[]> parsedResult;
        parsedResult = Tokenizer.tokenize(getTokenDefinitions(), input);
        
        int numRedo = 1;
        if (parsedResult.get("default")[1] != null) {
            numRedo = Integer.parseInt(parsedResult.get("default")[1]);
        }
        
        // We don't really have a nice way to support SQL transactions, so yeah >_<
        TodoListDB db = TodoListDB.getInstance();
        if (numRedo <= 0 || db.redoSize() <= 0) {
            UiManager.updateConsoleMessage(MESSAGE_FAILURE);
            return;
        }
        if (db.redoSize() < numRedo) {
            UiManager.updateConsoleMessage(String.format(MESSAGE_MULTIPLE_FAILURE,
                    numRedo, StringUtil.pluralizer(numRedo, "command", "commands"),
                    db.redoSize(), StringUtil.pluralizer(db.redoSize(), "command", "commands")));
            return;
        }
        for (int i = 0; i < numRedo; i++) {
            if (!db.redo()) {
                UiManager.updateConsoleMessage(MESSAGE_FAILURE);
                return;
            }
        }
        db = TodoListDB.getInstance();
        
        // Render
        Renderer.renderIndex(db, String.format(MESSAGE_SUCCESS, numRedo,
                StringUtil.pluralizer(numRedo, "command", "commands")));
    }
}
```
###### /java/seedu/todo/controllers/UndoController.java
``` java
 */
public class UndoController implements Controller {
    
    private static final String MESSAGE_SUCCESS = "Successfully undid %s %s!\nTo redo, type \"redo\".";
    private static final String MESSAGE_MULTIPLE_FAILURE = "We cannot undo %s %s! At most, you can undo %s %s.";
    private static final String MESSAGE_FAILURE = "There is no command to undo!";

    @Override
    public float inputConfidence(String input) {
        return input.toLowerCase().startsWith("undo") ? 1 : 0;
    }
    
    /**
     * Get the token definitions for use with <code>tokenizer</code>.<br>
     * This method exists primarily because Java does not support HashMap
     * literals...
     * 
     * @return tokenDefinitions
     */
    private static Map<String, String[]> getTokenDefinitions() {
        Map<String, String[]> tokenDefinitions = new HashMap<String, String[]>();
        tokenDefinitions.put("default", new String[] {"undo"});
        return tokenDefinitions;
    }

    @Override
    public void process(String input) throws ParseException {
        
        Map<String, String[]> parsedResult;
        parsedResult = Tokenizer.tokenize(getTokenDefinitions(), input);
        
        int numUndo = 1;
        if (parsedResult.get("default")[1] != null) {
            numUndo = Integer.parseInt(parsedResult.get("default")[1]);
        }
        
        // We don't really have a nice way to support SQL transactions, so yeah >_<
        TodoListDB db = TodoListDB.getInstance();
        if (numUndo <= 0 || db.undoSize() <= 0) {
            UiManager.updateConsoleMessage(MESSAGE_FAILURE);
            return;
        }
        if (db.undoSize() < numUndo) {
            UiManager.updateConsoleMessage(String.format(MESSAGE_MULTIPLE_FAILURE,
                    numUndo, StringUtil.pluralizer(numUndo, "command", "commands"),
                    db.undoSize(), StringUtil.pluralizer(db.undoSize(), "command", "commands")));
            return;
        }
        for (int i = 0; i < numUndo; i++) {
            if (!db.undo()) {
                UiManager.updateConsoleMessage(MESSAGE_FAILURE);
                return;
            }
        }
        db = TodoListDB.getInstance();
        
        // Render
        Renderer.renderIndex(db, String.format(MESSAGE_SUCCESS, numUndo,
                StringUtil.pluralizer(numUndo, "command", "commands")));
    }
}
```
###### /java/seedu/todo/controllers/UpdateController.java
``` java
 */
public class UpdateController implements Controller {
    
    private static final String NAME = "Update";
    private static final String DESCRIPTION = "Updates a task by listed index.";
    private static final String COMMAND_SYNTAX = "update <index> <task> by <deadline>";
    
    private static final String MESSAGE_UPDATE_SUCCESS = "Item successfully updated!";
    
    private static CommandDefinition commandDefinition =
            new CommandDefinition(NAME, DESCRIPTION, COMMAND_SYNTAX); 

    public static CommandDefinition getCommandDefinition() {
        return commandDefinition;
    }

    @Override
    public float inputConfidence(String input) {
        // TODO
        return (input.toLowerCase().startsWith("update")) ? 1 : 0;
    }

    @Override
    public void process(String args) {
        // TODO: Example of last minute work
        
        args = args.replaceFirst("update", "").trim();
        
        // Get index.
        System.out.println(args);
        
        Matcher matcher = Pattern.compile("^\\d+").matcher(args);
        matcher.find();
        String indexStr = matcher.group();
        int index = Integer.decode(indexStr.trim());
        
        // Parse name and date.
        args = args.replaceFirst(indexStr, "").trim();
        String[] splitted = args.split("( at | by )", 2);
        String name = splitted[0].trim();
        String naturalDate = splitted[1].trim();
        
        // Parse natural date using Natty.
        Parser parser = new Parser();
        List<DateGroup> groups = parser.parse(naturalDate);
        Date date = groups.get(0).getDates().get(0);
        LocalDateTime ldt = LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());
        
        // Get record
        EphemeralDB edb = EphemeralDB.getInstance();
        CalendarItem calendarItem = edb.getCalendarItemsByDisplayedId(index);
        TodoListDB db = TodoListDB.getInstance();
        
        if (calendarItem != null) {
            calendarItem.setName(name);
            calendarItem.setCalendarDT(ldt);
            db.save();
        }
        
        // Re-render
        Renderer.renderIndex(db, MESSAGE_UPDATE_SUCCESS);
    }
}
```
###### /java/seedu/todo/models/CalendarItem.java
``` java
 */
public interface CalendarItem {
    
    /**
     * Get the display name of the calendar item.
     * @return name
     */
    public String getName();
    
    /**
     * Set the display name of the calendar item.
     * @param name
     */
    public void setName(String name);

    /**
     * Get the calendar date of the calendar item. This is mostly for display
     * and sorting purposes.
     * 
     * @return datetime
     */
    public LocalDateTime getCalendarDT();
    
    /**
     * Set the calendar date of the calendar item. The behavior of this will
     * depend on the implementation, but it is guaranteed that the variable
     * being set by this method is the variable that is returned by
     * <code>getCalendarDT()</code>.<br>
     * 
     * It is unclear why one would ever set a calendar item's datetime using
     * this method, but it is here for completeness.
     * 
     * @param datetime
     */
    public void setCalendarDT(LocalDateTime datetime);
    
    /**
     * Returns true if the calendar item has passed, false otherwise.
     * 
     * @return isOver
     */
    public boolean isOver();
    
    /**
     * Returns the current tag list that belong to the CalendarItem, mainly for displaying purpose
     * 
     * @return ArrayList<String> tags
```
###### /java/seedu/todo/models/Event.java
``` java
 *
 */
public class Event implements CalendarItem {
    
    private String name;
    private LocalDateTime startDate;
    private LocalDateTime endDate;
    private ArrayList<String> tagList = new ArrayList<String>();
    
    private static final int MAX_TAG_LIST_SIZE = 20;
    
    /**
     * Get the start date of an Event.
     * @return startDate
     */
    public LocalDateTime getStartDate() {
        return startDate;
    }

    /**
     * Set the start date of an Event.
     * @param startDate
     */
    public void setStartDate(LocalDateTime startDate) {
        this.startDate = startDate;
    }

    /**
     * Get the end date of an Event.
     * @return endDate
     */
    public LocalDateTime getEndDate() {
        return endDate;
    }

    /**
     * Set the end date of an Event.
     * @param endDate
     */
    public void setEndDate(LocalDateTime endDate) {
        this.endDate = endDate;
    }

    @Override
    public String getName() {
        return this.name;
    }

    @Override
    public void setName(String name) {
        this.name = name;
    }

    @Override
    public LocalDateTime getCalendarDT() {
        return getStartDate(); 
    }

    @Override
    public void setCalendarDT(LocalDateTime datetime) {
        setStartDate(datetime);
    }
    
    @Override
    public boolean isOver() {
        if (endDate == null) {
            return false;
        } else {
            return endDate.isBefore(LocalDateTime.now());
        }
    }

    @Override
```
###### /java/seedu/todo/models/Task.java
``` java
 *
 */
public class Task implements CalendarItem {
    
    private String name;
    private LocalDateTime dueDate;
    private boolean isCompleted = false;
    private ArrayList<String> tagList = new ArrayList<String>();
    
    private static final int MAX_TAG_LIST_SIZE = 20;

    @Override
    public String getName() {
        return name;
    }

    @Override
    public void setName(String name) {
        this.name = name;
    }

    /**
     * Get the due date of a Task.
     * @return dueDate
     */
    public LocalDateTime getDueDate() {
        return dueDate;
    }

    /**
     * Set the due date of a Task.
     * @param dueDate
     */
    public void setDueDate(LocalDateTime dueDate) {
        this.dueDate = dueDate;
    }
    
    @Override
    public LocalDateTime getCalendarDT() {
        return getDueDate();
    }
    
    @Override
    public void setCalendarDT(LocalDateTime date) {
        setDueDate(date);
    }
    
    @Override
    public boolean isOver() {
        if (dueDate == null) {
            return false;
        } else {
            return dueDate.isBefore(LocalDateTime.now());
        }
    }

    /**
     * Returns true if the Task is completed, false otherwise.
     * @return isCompleted
     */
    public boolean isCompleted() {
        return isCompleted;
    }
    
    /**
     * Marks a Task as completed.
     */
    public void setCompleted() {
        this.isCompleted = true;
    }

    /**
     * Marks a Task as incomplete.
     */
    public void setIncomplete() {
        this.isCompleted = false;
    }

    @Override
```
###### /java/seedu/todo/models/TodoListDB.java
``` java
 *
 */
public class TodoListDB {

    private static TodoListDB instance = null;
    private static Storage storage = new JsonStorage();
    
    private Set<Task> tasks = new LinkedHashSet<Task>();
    private Set<Event> events = new LinkedHashSet<Event>();
    private Map<String, String> aliases = new HashMap<String, String>();
    private Set<String> tagList = new LinkedHashSet<String>();
    
    protected TodoListDB() {
        // Prevent instantiation.
    }
    
    public void setStorage(Storage storageToSet) {
        storage = storageToSet;
    }
    
    /**
     * Update the overall Tags that exist in the DB.
     * 
     */
    public void updateTagList(String tagName) {
        tagList.add(tagName);
    }
    
    /**
     * Get a list of Tags in the DB.
     * 
     * @return tagList
     */
    public List<String> getTagList() {
        return new ArrayList<String>(tagList);
    }
    
    /**
     * Count tags which are already inserted into the db
     * 
     * @return Number of tags
     */
    public int countTagList() {
        return tagList.size();
    }
    
    public Map<String, String> getAliases() {
        return aliases;
    }
    
    /**
     * Get a list of Tasks in the DB.
     * 
     * @return tasks
     */
    public List<Task> getAllTasks() {
        return new ArrayList<Task>(tasks);
    }

    
    /**
     * Count tasks which are not marked as complete, where {@code isComplete} is false.
     * 
     * @return Number of incomplete tasks
     */
    public int countIncompleteTasks() {
        int count = 0;
        for (Task task : tasks) {
            if (!task.isCompleted()) {
                count++;
            }
        }
        return count;
    }
    
    /**
     * Count tasks which are overdue, where {@code dueDate} is before the time now.
     * 
     * @return Number of overdue tasks
     */
    public int countOverdueTasks() {
        LocalDateTime now = LocalDateTime.now();
        int count = 0;
        for (Task task : tasks) {
            LocalDateTime dueDate = task.getDueDate();
            if (!task.isCompleted() && dueDate != null && dueDate.compareTo(now) < 0) {
                count++;
            }
        }
        return count;
    }
    
    /**
     * Get a list of Events in the DB.
     * 
     * @return events
     */
    public List<Event> getAllEvents() {
        return new ArrayList<Event>(events);
    }

    /**
     * Count events which are in the future, where {@code startDate} is after the time now.
     * 
     * @return Number of future events
     */
    public int countFutureEvents() {
        LocalDateTime now = LocalDateTime.now();
        int count = 0;
        for (Event event : events) {
            LocalDateTime startDate = event.getStartDate();
            if (startDate != null && startDate.compareTo(now) >= 0) {
                count++;
            }
        }
        return count;
    }
    
    /**
     * Create a new Task in the DB and return it.<br>
     * <i>The new record is not persisted until <code>save</code> is explicitly
     * called.</i>
     * 
     * @return task
     */
    public Task createTask() {
        Task task = new Task();
        tasks.add(task);
        return task;
    }
    
    /**
     * Destroys a Task in the DB and persists the commit.
     * 
     * @param task
     * @return true if the save was successful, false otherwise
     */
    public boolean destroyTask(Task task) {
        tasks.remove(task);
        return save();
    }
    
    /**
     * Destroys all Task in the DB and persists the commit.
     * 
     * @return true if the save was successful, false otherwise
```
###### /java/seedu/todo/models/TodoListDB.java
``` java
     */
    public Event createEvent() {
        Event event = new Event();
        events.add(event);
        return event;
    }
    
    /**
     * Destroys an Event in the DB and persists the commit.
     * 
     * @param event
     * @return true if the save was successful, false otherwise
     */
    public boolean destroyEvent(Event event) {
        events.remove(event);
        return save();
    }
    
    /**
     * Destroys all Event in the DB and persists the commit.
     * 
```
###### /java/seedu/todo/models/TodoListDB.java
``` java
     */
    public static TodoListDB getInstance() {
        if (instance == null) {
            instance = new TodoListDB();
        }
        return instance;
    }
    
    /**
     * Explicitly persists the database to disk.
     * 
     * @return true if the save was successful, false otherwise
     */
    public boolean save() {
        try {
            storage.save(this);
            return true;
        } catch (IOException e) {
            return false;
        }
    }
    
    /**
     * Explicitly reloads the database from disk.
     * 
     * @return true if the load was successful, false otherwise
     */
    public boolean load() {
        try {
            instance = storage.load();
            return true;
        } catch (IOException e) {
            return false;
        }
    }
    
    public void move(String newPath) throws IOException {
        storage.move(newPath);
    }
    
    /**
     * Returns the maximum possible number of undos.
     * 
     * @return undoSize
     */
    public int undoSize() {
        return storage.undoSize();
    }
    
    /**
     * Rolls back the DB by one commit.
     * 
     * @return true if the rollback was successful, false otherwise
     */
    public boolean undo() {
        try {
            instance = storage.undo();
            return true;
        } catch (CannotUndoException | IOException e) {
            return false;
        }
    }
    
    /**
     * Returns the maximum possible number of redos.
     * 
     * @return redoSize
     */
    public int redoSize() {
        return storage.redoSize();
    }
    
    /**
     * Rolls forward the DB by one undo commit.
     * 
     * @return true if the redo was successful, false otherwise
     */
    public boolean redo() {
        try {
            instance = storage.redo();
            return true;
        } catch (CannotRedoException | IOException e) {
            return false;
        }
    }
    
    /**
     * Get a list of events that are not over based on today date from the DB.
     * 
     * @return events
```
###### /java/seedu/todo/storage/JsonStorage.java
``` java
 */
public class JsonStorage implements Storage {
    
    // Ideally this would be a single circular-queue, but there is no such built-in
    // mechanism, and we would really really like to keep this operation O(1).
    private Deque<LinkedList<Patch>> historyPatch = new ArrayDeque<LinkedList<Patch>>();
    private Deque<LinkedList<Patch>> futurePatch = new ArrayDeque<LinkedList<Patch>>();
    private String currJson;
    private final static int HISTORY_SIZE = 1000;
    private final DiffMatchPatch dmp = new DiffMatchPatch();

    private File getStorageFile() {
        String filePath = MainApp.getConfig().getDatabaseFilePath();
        return new File(filePath);
    }
    
    /**
     * Internal function to prune the history patches stored to ensure it does
     * not exit HISTORY_SIZE.
     */
    private void pruneHistory() {
        // Don't need to worry about future because it cannot exceed limit.
        while (historyPatch.size() > HISTORY_SIZE) {
            historyPatch.removeFirst();
        }
    }
    
    @Override
    public void move(String newPath) throws IOException {
        boolean hasMoved = false;
        
        try {
            FileUtil.createParentDirsOfFile(new File(newPath));
        } catch (IOException e) {
            throw e;
        }
        
        try {
            hasMoved = getStorageFile().renameTo(new File(newPath));
        } catch (SecurityException e) {
            throw new IOException(e.getMessage(), e.getCause());
        }
        
        if (!hasMoved) {
            throw new IOException(String.format("Could not move file to \"%s\".", newPath));
        }
    }

    @Override
    public void save(TodoListDB db) throws JsonProcessingException, IOException {
        String newJson = JsonUtil.toJsonString(db);
        
        // Store the undo patch.
        if (this.currJson != null) {
            historyPatch.addLast(dmp.patchMake(newJson, this.currJson));
            pruneHistory();
            futurePatch.clear(); // A forward move nullifies all future patches.
        }
        
        // Update currJson and persist to disk.
        this.currJson = newJson;
        FileUtil.writeToFile(getStorageFile(), this.currJson);
    }

    @Override
    public TodoListDB load() throws IOException {
        this.currJson = FileUtil.readFromFile(getStorageFile());
        historyPatch.clear(); // It does not make sense to preserve history on load.
        return JsonUtil.fromJsonString(this.currJson, TodoListDB.class);
    }

    @Override
    public TodoListDB undo() throws CannotUndoException, IOException {
        // Get undo
        LinkedList<Patch> undoPatch;
        try {
            undoPatch = historyPatch.removeLast();
        } catch (NoSuchElementException e) {
            throw new CannotUndoException(e);
        }
        
        String newJson = (String)dmp.patchApply(undoPatch, this.currJson)[0];
        
        // Create redo
        LinkedList<Patch> redoPatch = dmp.patchMake(newJson, this.currJson);
        futurePatch.addLast(redoPatch);
        
        // Apply undo
        this.currJson = newJson;
        FileUtil.writeToFile(getStorageFile(), this.currJson);
        return JsonUtil.fromJsonString(this.currJson, TodoListDB.class);
    }
    
    @Override
    public int undoSize() {
        return historyPatch.size();
    }

    @Override
    public TodoListDB redo() throws CannotRedoException, IOException {
        // Get redo
        LinkedList<Patch> redoPatch;
        try {
            redoPatch = futurePatch.removeLast();
        } catch (NoSuchElementException e) {
            throw new CannotRedoException(e);
        }
        
        String newJson = (String)dmp.patchApply(redoPatch, this.currJson)[0];
        
        // Create undo
        LinkedList<Patch> undoPatch = dmp.patchMake(newJson, this.currJson);
        historyPatch.addLast(undoPatch);
        
        // Apply redo
        this.currJson = newJson;
        FileUtil.writeToFile(getStorageFile(), this.currJson);
        return JsonUtil.fromJsonString(this.currJson, TodoListDB.class);
    }
    
    @Override
    public int redoSize() {
        return futurePatch.size();
    }

}
```
###### /java/seedu/todo/storage/Storage.java
``` java
 */
public interface Storage {

    /**
     * Persists a TodoListDB object to disk.
     * @param db    TodoListDB object
     * @throws IOException  If there is an error writing to disk.
     */
    public void save(TodoListDB db) throws IOException;

    /**
     * Loads a TodoListDB object from disk
     * @return  TodoListDB object
     * @throws IOException  If there is an error reading from disk.
     */
    public TodoListDB load() throws IOException;

    public void move(String newPath) throws IOException;

    /**
     * Rolls back the DB by one commit, persists the DB, and returns a
     * TodoListDB object.
     * 
     * Undo information is on a per-session basis, and should not be persisted
     * to disk.
     * 
     * @return TodoListDB object
     * @throws CannotUndoException
     *             If there is nothing to undo.
     * @throws IOException
     *             If there is an error writing to disk.
     */
    public TodoListDB undo() throws CannotUndoException, IOException;

    /**
     * Rolls forward the DB by one undo commit, persists the DB, and returns a
     * TodoListDB object.
     * 
     * @return TodoListDB object
     * @throws CannotRedoException
     *             If there is nothing to redo.
     * @throws IOException
     *             If there is an error writing to disk.
     */
    public TodoListDB redo() throws CannotRedoException, IOException;
    
    /**
     * Returns the maximum possible number of undos.
     * @return undoSize
     */
    public int undoSize();
    
    /**
     * Returns the maximum possible number of redos.
     * @return
     */
    public int redoSize();

}
```
###### /java/seedu/todo/ui/components/AliasItem.java
``` java
 */
public class AliasItem extends MultiComponent {
    
    private static final String FXML_PATH = "components/AliasItem.fxml";
    
    // Props
    public AliasDefinition aliasDefinition;
    
    // FXML
    @FXML
    private Text aliasKey;
    @FXML
    private Text aliasValue;

    @Override
    public String getFxmlPath() {
        return FXML_PATH;
    }
    
    @Override
    public void componentDidMount() {
        if (aliasDefinition != null) {
            aliasKey.setText(aliasDefinition.getAliasKey());
            aliasValue.setText(aliasDefinition.getAliasValue());
        }
    }

}
```
###### /java/seedu/todo/ui/InputHandler.java
``` java
     */
    public boolean processInput(String input) {
        
        Map<String, String> aliases = MainApp.getConfig().getAliases();
        String aliasedInput = StringUtil.replaceAliases(input, aliases);
        Controller selectedController = null;
        
        if (this.handlingController != null) {
            selectedController = handlingController;
        } else {
            Controller[] controllers = instantiateAllControllers();

            // Define the controller which returns the maximum confidence.
            Controller maxController = null;

            // Get controller which has the maximum confidence.
            float maxConfidence = Integer.MIN_VALUE;

            for (int i = 0; i < controllers.length; i++) {
                float confidence = controllers[i].inputConfidence(aliasedInput);

                // Don't consider controllers with non-positive confidence.
                if (confidence <= 0) {
                    continue;
                }

                if (confidence > maxConfidence) {
                    maxConfidence = confidence;
                    maxController = controllers[i];
                }
            }

            // No controller exists with confidence > 0.
            if (maxController == null) {
                return false;
            }

            // Select best-matched controller.
            selectedController = maxController;

        }
        
        // Process using best-matched controller.
        try {
            // Alias and unalias should not receive an aliasedInput for proper functioning.
            if (selectedController.getClass() == AliasController.class ||
                    selectedController.getClass() == UnaliasController.class) {
                selectedController.process(input);
            } else {
                selectedController.process(aliasedInput);
            }
        } catch (ParseException e) {
            return false;
        }
        
        // Since command is not invalid, we push it to history
        pushCommand(aliasedInput);

        return true;
    }
    
    private Controller[] instantiateAllControllers() {
        return new Controller[] { new AliasController(),
                                  new UnaliasController(),
                                  new HelpController(),
                                  new AddController(),
                                  new ListController(),
                                  new DestroyController(),
                                  new CompleteTaskController(),
                                  new UncompleteTaskController(),
                                  new UpdateController(),
                                  new UndoController(),
                                  new RedoController(),
                                  new ConfigController(),
                                  new ClearController(),
                                  new FindController(),
                                  new TagController(),
                                  new UntagController(),
                                  new ExitController() };
    }

}
```
###### /java/seedu/todo/ui/views/AliasView.java
``` java
 */
public class AliasView extends View {
    
    private static final String FXML_PATH = "views/AliasView.fxml";

    private static final String ICON_PATH = "/images/icon-settings.png";
    private static final String TEXT_INSTRUCTIONS = "Aliases make your life easier by allowing you to customize shortcuts!\n"
            + "To set an alias, use the following command:\n    alias <aliasKey> <aliasValue>";

    // FXML
    @FXML
    private Text aliasInstructionsText;
    @FXML
    private ImageView aliasImageView;
    @FXML
    private Pane aliasesPlaceholder;

    @Override
    public String getFxmlPath() {
        return FXML_PATH;
    }

    @Override
    public void componentDidMount() {
        // Makes the Component full width wrt parent container.
        FxViewUtil.makeFullWidth(this.mainNode);
        
        // Set instructions
        aliasInstructionsText.setText(TEXT_INSTRUCTIONS);

        // Load image
        aliasImageView.setImage(new Image(ICON_PATH));
        
        // Get definitions
        Map<String, String> aliasMap = MainApp.getConfig().getAliases();
        List<Map.Entry<String, String>> aliasDefinitions =
                new ArrayList<Map.Entry<String, String>>(aliasMap.entrySet());
        
        Comparator<Map.Entry<String, String>> aliasComparator = new Comparator<Map.Entry<String, String>>() {
            @Override
            public int compare(Entry<String, String> o1, Entry<String, String> o2) {
                return o1.getKey().compareTo(o2.getKey());
            }
        };
        Collections.sort(aliasDefinitions, aliasComparator);

        // Clear items
        AliasItem.reset(aliasesPlaceholder);

        // Load items
        for (Map.Entry<String, String> aliasPair : aliasDefinitions) {
            AliasItem item = load(primaryStage, aliasesPlaceholder, AliasItem.class);
            item.aliasDefinition = new AliasDefinition(aliasPair.getKey(), aliasPair.getValue());
            item.render();
        }
    }
    
}
```
###### /resources/ui/components/AliasItem.fxml
``` fxml
<VBox styleClass="tasklist-dateitem" maxHeight="Infinity" maxWidth="Infinity" minHeight="-Infinity" minWidth="-Infinity" 
  xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" 
  fx:controller="seedu.todo.ui.components.AliasItem">
  <children>

    <HBox alignment="CENTER_LEFT">
      <children>
        <Text fx:id="aliasKey" wrappingWidth="100.0" VBox.vgrow="ALWAYS" />
        <Text fx:id="aliasValue" VBox.vgrow="ALWAYS" />
      </children>
    </HBox>
    
  </children>
  <padding>
    <Insets bottom="10.0" />
  </padding>
</VBox>
```
###### /resources/ui/views/AliasView.fxml
``` fxml
<VBox maxHeight="Infinity" maxWidth="Infinity" minHeight="100" minWidth="100" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.todo.ui.views.AliasView">
  <children>
    <HBox alignment="CENTER_LEFT">
      <children>
        <ImageView fitHeight="32.0" fitWidth="32.0" fx:id="aliasImageView" pickOnBounds="true" preserveRatio="true">
          <HBox.margin>
            <Insets right="10.0" />
          </HBox.margin>
        </ImageView>
        <Text styleClass="font-300, view-title-text" text="Command Aliases" />
      </children>
      <VBox.margin>
        <Insets bottom="20.0" />
      </VBox.margin>
    </HBox>
    
    <Text fx:id="aliasInstructionsText">
      <VBox.margin>
        <Insets bottom="20.0" />
      </VBox.margin>
    </Text>

    <ScrollPane fitToHeight="true" fitToWidth="true" VBox.vgrow="ALWAYS">
      <content>
        <VBox styleClass="alias-pane" fx:id="aliasesPlaceholder" VBox.vgrow="ALWAYS">
          <padding>
            <Insets bottom="20.0" />
          </padding>
        </VBox>
      </content>
    </ScrollPane>
  </children>

  <padding>
    <Insets top="20.0" left="20.0" bottom="20.0" right="20.0" />
  </padding>
</VBox>
```
