# A0093907W
###### \java\seedu\todo\commons\core\AliasDefinition.java
``` java
/**
 * Container class to store and retrieve a pair of values for an alias key -> value pair.
 */
public class AliasDefinition {
    private String aliasKey;
    private String aliasValue;
    
    public AliasDefinition(String aliasKey, String aliasValue) {
        this.aliasKey = aliasKey;
        this.aliasValue = aliasValue;
    }
    
    public String getAliasKey() {
        return aliasKey;
    }

    public String getAliasValue() {
        return aliasValue;
    }

}
```
###### \java\seedu\todo\commons\EphemeralDB.java
``` java
/**
 * A bit like Redis, essentially a data store for things that should not be
 * persisted to disk, but should be shared between all modules.
 * 
 * All variables should be public. In-place modifications of variables are
 * encouraged.
 */
public class EphemeralDB {

    private static EphemeralDB instance = null;

    // Stores
    public List<CalendarItem> displayedCalendarItems = new ArrayList<>();

    
    protected EphemeralDB() {
        // Prevent instantiation.
    }

    /**
     * Gets the singleton instance of the EphemeralDB.
     * 
     * @return EphemeralDB
     */
    public static EphemeralDB getInstance() {
        if (instance == null) {
            instance = new EphemeralDB();
        }
        return instance;
    }
    
    
    /** ======== DISPLAYED CALENDAR ITEMS ======== **/

    /**
     * Returns a CalendarItem from all displayedCalendarItems according to their displayed ID.
     * Note that displayedCalendarItems stores the indexes of the last displayed list of CalendarItems.
     * Their displayed ID is simply their index in the ArrayList + 1 (due to 0-indexing of ArrayLists).
     * 
     * @param id   Display ID of task. Bounded between 1 and the size of the ArrayList.
     * @return     Returns the Task at the specified display index.
     */
    public CalendarItem getCalendarItemsByDisplayedId(int id) {
        if (id <= 0 || id > displayedCalendarItems.size()) {
            return null;
        } else {
            return displayedCalendarItems.get(id - 1);
        }
    }

    /**
     * Adds a CalendarItem to displayedCalendarItems in EphemeralDB. 
     * Returns the 1-indexed index of the added item.
     * 
     * @param item   CalendarItem to add to displayedCalendarItems.
     * @return       List index (1-index) of the added item.
     */
    public int addToDisplayedCalendarItems(CalendarItem item) {
        displayedCalendarItems.add(item);
        return displayedCalendarItems.size();
    }
    
    /**
     * Clears displayedCalendarItems.
     */
    public void clearDisplayedCalendarItems() {
        displayedCalendarItems.clear();
    }

}
```
###### \java\seedu\todo\controllers\AddController.java
``` java
/**
 * Controller to add an event or task.
 */
public class AddController extends Controller {
    
    private static final String NAME = "Add";
    private static final String DESCRIPTION = "Adds a task / event to the to-do list.\n"
                                            + "Accepts natural date formats (e.g. \"Today 5pm\" is allowed).";
    private static final String COMMAND_SYNTAX = "add <task> by <deadline> || add <event> from <start_date> to <end_date>";
    private static final String COMMAND_KEYWORD = "add";

    private static final String MESSAGE_ADD_SUCCESS = "Item successfully added!";
    private static final String STRING_WHITESPACE = "";
    private static final String ADD_EVENT_TEMPLATE = "add event \"%s\" from \"%s\" to \"%s\"";
    private static final String ADD_TASK_TEMPLATE = "add task \"%s\" by \"%s\"";
    private static final String START_TIME_FIELD = "<start time>";
    private static final String END_TIME_FIELD = "<end time>";
    private static final String DEADLINE_FIELD = "<deadline>";
    private static final String NAME_FIELD = "<name>";
    
    private static CommandDefinition commandDefinition =
            new CommandDefinition(NAME, DESCRIPTION, COMMAND_SYNTAX, COMMAND_KEYWORD);

    @Override
    public CommandDefinition getCommandDefinition() {
        return commandDefinition;
    }
    
    /**
     * Get the token definitions for use with <code>tokenizer</code>.<br>
     * This method exists primarily because Java does not support HashMap
     * literals...
     * 
     * @return tokenDefinitions
     */
    private static Map<String, String[]> getTokenDefinitions() {
        Map<String, String[]> tokenDefinitions = new HashMap<String, String[]>();
        tokenDefinitions.put("default", new String[] {"add"});
        tokenDefinitions.put("eventType", new String[] { "event", "task" });
        tokenDefinitions.put("time", new String[] { "at", "by", "on", "before", "time" });
        tokenDefinitions.put("timeFrom", new String[] { "from" });
        tokenDefinitions.put("timeTo", new String[] { "to" });
        return tokenDefinitions;
    }

    @Override
    public void process(String input) throws ParseException {
        Map<String, String[]> parsedResult;
        parsedResult = Tokenizer.tokenize(getTokenDefinitions(), input);
        
        // Task or event?
        boolean isTask = parseIsTask(parsedResult);
        
        // Name
        String name = parseName(parsedResult);
        
        // Time
        String[] naturalDates = DateParser.extractDatePair(parsedResult);
        String naturalFrom = naturalDates[0];
        String naturalTo = naturalDates[1];
        
        // Parse natural date using Natty.
        LocalDateTime dateFrom;
        LocalDateTime dateTo;
        try {
            dateFrom = naturalFrom == null ? null : DateParser.parseNatural(naturalFrom);
            dateTo = naturalTo == null ? null : DateParser.parseNatural(naturalTo);
        } catch (InvalidNaturalDateException e) {
            renderDisambiguation(isTask, name, naturalFrom, naturalTo);
            return;
        }

        // Validate isTask, name and times.
        if (!validateParams(isTask, name, dateFrom, dateTo)) {
            renderDisambiguation(isTask, name, naturalFrom, naturalTo);
            return;
        }
        
        // Create and persist task / event.
        TodoListDB db = TodoListDB.getInstance();
        createCalendarItem(db, isTask, name, dateFrom, dateTo);
        
        // Re-render
        Renderer.renderIndex(db, MESSAGE_ADD_SUCCESS);
    }

    /**
     * Creates and persists a CalendarItem to the DB.
     * 
     * @param db
     *            TodoListDB object
     * @param isTask
     *            true if CalendarItem should be a Task, false if Event
     * @param name
     *            Display name of CalendarItem object
     * @param dateFrom
     *            Due date for Task or start date for Event
     * @param dateTo
     *            End date for Event
     */
    private void createCalendarItem(TodoListDB db, 
            boolean isTask, String name, LocalDateTime dateFrom, LocalDateTime dateTo) {
        if (isTask) {
            Task newTask = db.createTask();
            newTask.setName(name);
            newTask.setDueDate(dateFrom);
        } else {
            Event newEvent = db.createEvent();
            newEvent.setName(name);
            newEvent.setStartDate(dateFrom);
            newEvent.setEndDate(dateTo);
        }
        db.save();
    }

    
    /**
     * Validates the parsed parameters.
     * 
     * <ul>
     * <li>Fail if name is invalid</li>
     * </ul>
     * 
     * Tasks:
     * <ul>
     * <li>Fail if task has a dateTo</li>
     * </ul>
     * 
     * Events:
     * <ul>
     * <li>Fail if event does not have both dateFrom and dateTo</li>
     * <li>Fail if event has a dateTo that is before dateFrom</li>
     * </ul>
     * 
     * @param isTask
     *            true if CalendarItem should be a Task, false if Event
     * @param name
     *            Display name of CalendarItem object
     * @param dateFrom
     *            Due date for Task or start date for Event
     * @param dateTo
     *            End date for Event
     * @return true if validation passed, false otherwise
     */
    private boolean validateParams(boolean isTask, String name, LocalDateTime dateFrom, LocalDateTime dateTo) {
        return (!(name == null || name.length() == 0            // Invalid name
                || (isTask && dateTo != null)                   // Task with dateTo
                || (!isTask && dateFrom == null)                // Event without dateFrom
                || (!isTask && dateTo == null)                  // Event without dateTo
                || (!isTask && dateTo.isBefore(dateFrom))));    // Event with dateTo before dateFrom
    }

    /**
     * Extracts the display name of the CalendarItem from parsedResult.
     * 
     * @param parsedResult
     * @return name
     */
    private String parseName(Map<String, String[]> parsedResult) {
        String name = null;
        if (parsedResult.get("default") != null && parsedResult.get("default")[1] != null) {
            name = parsedResult.get("default")[1];
        }
        if (parsedResult.get("eventType") != null && parsedResult.get("eventType")[1] != null) {
            name = parsedResult.get("eventType")[1];
        }
        return name;
    }

    /**
     * Extracts the intended CalendarItem type from parsedResult.
     * 
     * @param parsedResult
     * @return true if Task, false if Event
     */
    private boolean parseIsTask(Map<String, String[]> parsedResult) {
        boolean isTask = true;
        if (parsedResult.get("eventType") != null && parsedResult.get("eventType")[0].equals("event")) {
            isTask = false;
        }
        return isTask;
    }
    
    /**
     * Disambiguate an ambiguous input by auto-populating a templated command on
     * a best-effort basis.
     * 
     * @param isTask
     * @param name
     * @param naturalFrom
     * @param naturalTo
     */
    private void renderDisambiguation(boolean isTask, String name, String naturalFrom, String naturalTo) {
        name = StringUtil.replaceEmpty(name, NAME_FIELD);

        String disambiguationString;
        String errorMessage = STRING_WHITESPACE;
        
        if (isTask) {
            naturalFrom = StringUtil.replaceEmpty(naturalFrom, DEADLINE_FIELD);
            disambiguationString = String.format(ADD_TASK_TEMPLATE, name, naturalFrom);
        } else {
            naturalFrom = StringUtil.replaceEmpty(naturalFrom, START_TIME_FIELD);
            naturalTo = StringUtil.replaceEmpty(naturalTo, END_TIME_FIELD);
            disambiguationString = String.format(ADD_EVENT_TEMPLATE, name, naturalFrom, naturalTo);
        }
        
        // Show an error in the console
        Renderer.renderDisambiguation(disambiguationString, errorMessage);
    }
    
}
```
###### \java\seedu\todo\controllers\AliasController.java
``` java
/**
 * Controller to declare aliases
 */
public class AliasController extends Controller {
    
    private static final String NAME = "Alias";
    private static final String DESCRIPTION = "Shows current aliases or updates them.";
    private static final String COMMAND_SYNTAX = "alias [<alias key> <alias value>]";
    private static final String COMMAND_KEYWORD = "alias";
    
    private static final String SPACE = " ";
    private static final int ARGS_LENGTH = 2;
    private static final String MESSAGE_SHOWING = "Showing all aliases.";
    private static final String MESSAGE_SAVE_SUCCESS = "Successfully saved alias!";
    private static final String MESSAGE_INVALID_NUM_PARAMS = "Seems like you have provided an invalid number of parameters!";
    private static final String MESSAGE_INVALID_INPUT = "Invalid alias parameters! Alias inputs must consist solely "
                                                      + "of alphabetical characters.";
    private static final String SAVE_ERROR = "There was an error saving your aliases. Please try again.";
    private static final String ALIAS_TEMPLATE = "alias %s %s";
    private static final String ALIAS_VALUE_FIELD = "<alias value>";
    private static final String ALIAS_KEY_FIELD = "<alias key>";
    
    private static CommandDefinition commandDefinition =
            new CommandDefinition(NAME, DESCRIPTION, COMMAND_SYNTAX, COMMAND_KEYWORD); 

    @Override
    public CommandDefinition getCommandDefinition() {
        return commandDefinition;
    }

    @Override
    public void process(String input) {
        String params = input.replaceFirst("alias", "").trim();

        if (params.length() <= 0) {
            Renderer.renderAlias(MESSAGE_SHOWING);
            return;
        }
        
        String[] args = params.split(SPACE, ARGS_LENGTH);
        
        String aliasKey = null;
        String aliasValue = null;
        
        // Best-effort matching, disambiguate if wrong.
        validate: {
            switch (args.length) {
                case 0:
                    break;
                case 1:
                    aliasKey = args[0];
                    break;
                case 2: // All good!
                    aliasKey = args[0];
                    aliasValue = args[1];
                    break validate;
                default:
                    aliasKey = args[0];
                    aliasValue = args[0];
                    break;
            }
            renderDisambiguation(aliasKey, aliasValue, MESSAGE_INVALID_NUM_PARAMS);
            return;
        }
        
        if (!validateAlias(aliasKey) || !validateAlias(aliasValue)) {
            renderDisambiguation(aliasKey, aliasValue, MESSAGE_INVALID_INPUT);
            return;
        }
        
        // Persist alias mapping
        try {
            saveAlias(aliasKey, aliasValue);
        } catch (IOException e) {
            Renderer.renderAlias(SAVE_ERROR);
            return;
        }
        
        Renderer.renderAlias(MESSAGE_SAVE_SUCCESS);
    }
    
    /**
     * Persists an alias mapping to the database.
     * 
     * @param db    TodoListDB singleton
     * @param aliasKey
     * @param aliasValue
     * @throws IOException 
     */
    private static void saveAlias(String aliasKey, String aliasValue) throws IOException {
        Config config = ConfigCenter.getInstance().getConfig();
        Map<String, String> aliases = config.getAliases();
        aliases.put(aliasKey, aliasValue);
        ConfigCenter.getInstance().saveConfig(config);
        
    }
    
    /**
     * Validates that string is sanitized and safe for aliasing.
     * 
     * @param alias     string to check
     * @return          true if string is sanitized, false otherwise
     */
    private static boolean validateAlias(String alias) {
        return alias.chars().allMatch(Character::isLetter);
    }
    
    /**
     * Disambiguate an ambiguous input by auto-populating a templated command on
     * a best-effort basis.
     * 
     * @param aliasKey
     * @param aliasValue
     * @param message
     */
    private static void renderDisambiguation(String aliasKey, String aliasValue, String message) {
        String sanitizedAliasKey = StringUtil.sanitize(aliasKey);
        sanitizedAliasKey = StringUtil.replaceEmpty(sanitizedAliasKey, ALIAS_KEY_FIELD);
        String sanitizedAliasValue = StringUtil.sanitize(aliasValue);
        sanitizedAliasValue = StringUtil.replaceEmpty(sanitizedAliasValue, ALIAS_VALUE_FIELD);
        Renderer.renderDisambiguation(String.format(ALIAS_TEMPLATE,
                sanitizedAliasKey, sanitizedAliasValue), message);
    }

}
```
###### \java\seedu\todo\controllers\ClearController.java
``` java
/**
 * Controller to clear task/event by type or status
 */
public class ClearController extends Controller {
    
    private static final String NAME = "Clear";
    private static final String DESCRIPTION = "Clear all tasks/events or by specify date.";
    private static final String COMMAND_SYNTAX = "clear [task/event] [on date]";
    private static final String COMMAND_KEYWORD = "clear";
    
    private static final String MESSAGE_CLEAR_NO_ITEMS_FOUND = "No items matched your query!";
    private static final String MESSAGE_CLEAR_SUCCESS = "A total of %s %s and %s %s deleted!\n" + "To undo, type \"undo\".";
    public static final String MESSAGE_UNKNOWN_TOKENS = "Could not parse your query as it contained unknown tokens: %s";
    public static final String MESSAGE_AMBIGUOUS_TYPE = "We could not tell if you wanted to clear events or tasks. \n"
            + "Note that only tasks can be \"complete\"/\"incomplete\", "
            + "while only events can be \"past\", \"over\" or \"future\".";
    public static final String MESSAGE_INVALID_DATE = "We could not parse the date in your query, please try again.";
    
    private static final String CLEAR_TEMPLATE = "clear [name \"%s\"] [from \"%s\"] [to \"%s\"] [tag \"%s\"]";
    private static final String CLEAR_TASKS_TEMPLATE = "clear tasks [name \"%s\"] [\"%s\"] [from \"%s\"] [to \"%s\"] [tag \"%s\"]";
    private static final String CLEAR_EVENTS_TEMPLATE = "clear events [name \"%s\"] [\"%s\"] [from \"%s\"] [to \"%s\"] [tag \"%s\"]";
    

    private static CommandDefinition commandDefinition =
            new CommandDefinition(NAME, DESCRIPTION, COMMAND_SYNTAX, COMMAND_KEYWORD); 

    @Override
    public CommandDefinition getCommandDefinition() {
        return commandDefinition;
    }
    
    @Override
    public void process(String input) throws ParseException {
        // Tokenize input
        Map<String, String[]> parsedResult =
                Tokenizer.tokenize(CalendarItemFilter.getFilterTokenDefinitions(), input);
        
        // Check if there are any unknown tokens.
        if (Disambiguator.getUnknownTokenString(parsedResult) != null) {
            String errorMessage = String.format(MESSAGE_UNKNOWN_TOKENS, Disambiguator.getUnknownTokenString(parsedResult));
            renderDisambiguation(parsedResult, true, true, errorMessage);
            return;
        }
        
        // Decide if task/event/both
        boolean[] isTaskEvent = null;
        try {
            isTaskEvent = CalendarItemFilter.parseIsTaskEvent(parsedResult);
        } catch (AmbiguousEventTypeException e) {
            renderDisambiguation(parsedResult, true, true, MESSAGE_AMBIGUOUS_TYPE);
            return;
        }
        
        boolean filterTask = isTaskEvent[0];
        boolean filterEvent = isTaskEvent[1];
        
        List<Task> clearTasks = new ArrayList<Task>();
        List<Event> clearEvents = new ArrayList<Event>();
        try {
            if (filterTask) {
                clearTasks = CalendarItemFilter.filterTasks(parsedResult);
            }
            if (filterEvent) {
                clearEvents = CalendarItemFilter.filterEvents(parsedResult);
            }
        } catch (InvalidNaturalDateException e) {
            renderDisambiguation(parsedResult, filterTask, filterEvent, MESSAGE_INVALID_DATE);
            return;
        }
        
        // Clear them all!
        TodoListDB db = TodoListDB.getInstance();
        
        if (clearTasks.size() == 0 && clearEvents.size() == 0) {
            Renderer.renderIndex(db, MESSAGE_CLEAR_NO_ITEMS_FOUND);
            return;
        }
        
        db.destroyTasks(clearTasks);
        db.destroyEvents(clearEvents);
        db.save();
        
        String consoleMessage = String.format(MESSAGE_CLEAR_SUCCESS,
                clearTasks.size(), StringUtil.pluralizer(clearTasks.size(), "task", "tasks"),
                clearEvents.size(), StringUtil.pluralizer(clearEvents.size(), "event", "events"));
        
        Renderer.renderIndex(db, consoleMessage);
    }
    
    
    /**
     * Disambiguate an ambiguous input by auto-populating a templated command on
     * a best-effort basis.
     * 
     * @param parsedResult
     * @param filterTask
     * @param filterEvent
     * @param errorMessage
     */
    private void renderDisambiguation(Map<String, String[]> parsedResult, boolean filterTask, boolean filterEvent, String errorMessage) {
        Map<String, String> extractedTokens = Disambiguator.extractParsedTokens(parsedResult);
        String consoleCommand;
        
        if ((filterTask && filterEvent) || (!filterTask && !filterEvent)) {
            consoleCommand = String.format(CLEAR_TEMPLATE, extractedTokens.get("name"), extractedTokens.get("startTime"), 
                    extractedTokens.get("endTime"), extractedTokens.get("tag"));
        } else if (filterTask) {
            consoleCommand = String.format(CLEAR_TASKS_TEMPLATE, extractedTokens.get("name"), extractedTokens.get("taskStatus"), 
                    extractedTokens.get("startTime"), extractedTokens.get("endTime"), extractedTokens.get("tag"));
        } else {
            consoleCommand = String.format(CLEAR_EVENTS_TEMPLATE, extractedTokens.get("name"), extractedTokens.get("eventStatus"), 
                    extractedTokens.get("startTime"), extractedTokens.get("endTime"), extractedTokens.get("tag"));
        }
        
        Renderer.renderDisambiguation(consoleCommand, errorMessage);
    }
}
```
###### \java\seedu\todo\controllers\concerns\CalendarItemFilter.java
``` java
/**
 * Class to store CalendarItem filtering methods to be shared across controllers.
 */
public class CalendarItemFilter {
    
    /**
     * Get the token definitions for use with <code>tokenizer</code>.<br>
     * This method exists primarily because Java does not support HashMap
     * literals...
     * 
     * @return tokenDefinitions
     */
    public static Map<String, String[]> getFilterTokenDefinitions() {
        Map<String, String[]> tokenDefinitions = new HashMap<String, String[]>();
        tokenDefinitions.put("default", new String[] { "clear", "list" });
        tokenDefinitions.put("eventType", new String[] { "event", "events", "task", "tasks" });
        tokenDefinitions.put("name", new String[] { "name" });
        tokenDefinitions.put("taskStatus", new String[] { "complete" , "completed", "incomplete", "incompleted" });
        tokenDefinitions.put("eventStatus", new String[] { "over" , "past", "future" });
        tokenDefinitions.put("timeFrom", new String[] { "from", "after" });
        tokenDefinitions.put("timeTo", new String[] { "to", "before", "until", "by" });
        tokenDefinitions.put("tag", new String[] { "tag" });
        return tokenDefinitions;
    }
    
    /**
     * Returns a boolean array of {isTask, isEvent} which specifies if we should
     * filter tasks, events or both.
     * 
     * If there is no eventType specified, we will filter both.
     * 
     * <ol>
     * <li>If no "task"/"event" token, and no eventStatus/taskStatus token, then filter both</li>
     * <li>If no "task"/"event" token, and exactly one of eventStatus/taskStatus present, then use it to guess</li>
     * <li>If "task" token found, then assert no eventStatus token</li>
     * <li>If "event" token found, then assert no taskStatus token</li>
     * <li>Assert that eventStatus and taskStatus tokens cannot both be present</li>
     * </ol>
     * 
     * @param parsedResult
     * @return {isTask, isEvent}
     */
    public static boolean[] parseIsTaskEvent(Map<String, String[]> parsedResult) throws AmbiguousEventTypeException {
        // Extract relevant params
        String eventType = null;
        if (parsedResult.get("eventType") != null) {
            eventType = parsedResult.get("eventType")[0];
            // Singularize
            eventType = "events".equals(eventType) ? "event" : eventType;
            eventType = "tasks".equals(eventType) ? "task" : eventType;
        }
        boolean taskStatusPresent = parsedResult.get("taskStatus") != null;
        boolean eventStatusPresent = parsedResult.get("eventStatus") != null;

        if (eventType == null) {
            if (!taskStatusPresent && !eventStatusPresent) {
                // Condition 1
                return new boolean[] { true, true };
            } else if (eventStatusPresent && !taskStatusPresent) {
                // Condition 2 - Task
                return new boolean[] { false, true };
            } else if (taskStatusPresent && !eventStatusPresent) {
                // Condition 2 - Event
                return new boolean[] { true, false };
            }
        } else {
            if ("task".equals(eventType) && !eventStatusPresent) {
                // Condition 3
                return new boolean[] { true, false };
            } else if ("event".equals(eventType) && !taskStatusPresent) {
                // Condition 4
                return new boolean[] { false, true };
            }
        }
        
        // If we made it here, then at least one assertion was violated.
        throw new AmbiguousEventTypeException("Couldn't determine if task or event!");
    }
    
    
    public static List<Task> filterTasks(Map<String, String[]> parsedResult) throws InvalidNaturalDateException {
        List<Predicate<Task>> taskPredicates = new ArrayList<Predicate<Task>>();
        
        // Filter by name
        if (parsedResult.get("name") != null) {
            taskPredicates.add(Task.predByName(parsedResult.get("name")[1]));
        }
        
        // Filter by taskStatus
        if (parsedResult.get("taskStatus") != null) {
            String taskStatus = parsedResult.get("taskStatus")[0];
            if ("complete".equals(taskStatus) || "completed".equals(taskStatus)) {
                taskPredicates.add(Task.predCompleted(true));
            } else {
                taskPredicates.add(Task.predCompleted(false));
            }
        }
        
        // Filter by dueDate
        String[] datePair = DateParser.extractDatePair(parsedResult);
        String timeStartNatural = datePair[0];
        String timeEndNatural = datePair[1];
        if (timeStartNatural != null) {
            LocalDateTime timeStart = DateParser.parseNatural(timeStartNatural);
            taskPredicates.add(Task.predAfterDueDate(timeStart));
        }
        if (timeEndNatural != null) {
            LocalDateTime timeEnd = DateParser.parseNatural(timeEndNatural);
            taskPredicates.add(Task.predBeforeDueDate(timeEnd));
        }
        
        // Filter by tag
        if (parsedResult.get("tag") != null && parsedResult.get("tag")[1] != null) {
            taskPredicates.add(Task.predTag(parsedResult.get("tag")[1]));
        }
        
        return Task.where(taskPredicates);
    }
    
    public static List<Event> filterEvents(Map<String, String[]> parsedResult) throws InvalidNaturalDateException {
        List<Predicate<Event>> eventPredicates = new ArrayList<Predicate<Event>>();
        
        // Filter by name
        if (parsedResult.get("name") != null) {
            eventPredicates.add(Event.predByName(parsedResult.get("name")[1]));
        }
        
        // Filter by eventStatus
        if (parsedResult.get("eventStatus") != null && parsedResult.get("eventStatus")[0] != null) {
            String eventStatus = parsedResult.get("eventStatus")[0];
            LocalDateTime now = LocalDateTime.now();
            if ("over".equals(eventStatus) || "past".equals(eventStatus)) {
                eventPredicates.add(Event.predEndBefore(now));
            } else if ("future".equals(eventStatus)) {
                eventPredicates.add(Event.predStartAfter(now));
            }
        }
        
        // Filter by time
        String[] datePair = DateParser.extractDatePair(parsedResult);
        String timeStartNatural = datePair[0];
        String timeEndNatural = datePair[1];
        if (timeStartNatural != null) {
            LocalDateTime timeStart = DateParser.parseNatural(timeStartNatural);
            eventPredicates.add(Event.predStartAfter(timeStart));
        }
        if (timeEndNatural != null) {
            LocalDateTime timeEnd = DateParser.parseNatural(timeEndNatural);
            eventPredicates.add(Event.predEndBefore(timeEnd));
        }
        
        // Filter by tag
        if (parsedResult.get("tag") != null && parsedResult.get("tag")[1] != null) {
            eventPredicates.add(Event.predTag(parsedResult.get("tag")[1]));
        }
        
        return Event.where(eventPredicates);
    }

}
```
###### \java\seedu\todo\controllers\concerns\DateParser.java
``` java
/**
 * Class to store date parsing methods to be shared across controllers.
 */
public class DateParser {
    
    /**
     * Extracts the natural dates from parsedResult.
     * 
     * @param parsedResult
     * @return { naturalFrom, naturalTo }
     */
    public static String[] extractDatePair(Map<String, String[]> parsedResult) {
        String naturalFrom = null;
        String naturalTo = null;
        setTime: {
            if (parsedResult.get("time") != null && parsedResult.get("time")[1] != null) {
                naturalFrom = parsedResult.get("time")[1];
                break setTime;
            }
            if (parsedResult.get("timeFrom") != null && parsedResult.get("timeFrom")[1] != null) {
                naturalFrom = parsedResult.get("timeFrom")[1];
            }
            if (parsedResult.get("timeTo") != null && parsedResult.get("timeTo")[1] != null) {
                naturalTo = parsedResult.get("timeTo")[1];
            }
        }
        return new String[] { naturalFrom, naturalTo };
    }
    
    /**
     * Parse a natural date into a LocalDateTime object.
     * 
     * @param natural
     * @return LocalDateTime object
     * @throws InvalidNaturalDateException 
     */
    public static LocalDateTime parseNatural(String natural) throws InvalidNaturalDateException {
        Parser parser = new Parser();
        List<DateGroup> groups = parser.parse(natural);
        Date date = null;
        try {
            date = groups.get(0).getDates().get(0);
        } catch (IndexOutOfBoundsException e) {
            throw new InvalidNaturalDateException(natural);
        }
        LocalDateTime ldt = LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());
        return ldt;
    }

}
```
###### \java\seedu\todo\controllers\concerns\Renderer.java
``` java
 * 
 * Class to store rendering methods to be shared across controllers.
 *
 */
public class Renderer {

    public static final String MESSAGE_DISAMBIGUATE = "Your last command wasn't clear, please fix your command and try again.";
    
    /**
     * Renders an error message in both the console and the input field, leave null or empty string if not needed.
     * @param replacedCommand    Value to display in the input field
     * @param detailedError       Message to be rendered in the console
     */
    public static void renderDisambiguation(String replacedCommand, String detailedError) {
        // Update console input field
        if (replacedCommand != null && replacedCommand.length() > 0) {
            UiManager.updateConsoleInputValue(replacedCommand);
        }
        
        // Update console message
        if (detailedError != null && detailedError.length() > 0) {
            UiManager.updateConsoleMessage(String.format("%s\n\n%s", MESSAGE_DISAMBIGUATE, detailedError));
        } else {
            UiManager.updateConsoleMessage(String.format("%s", MESSAGE_DISAMBIGUATE));
        }
    }
    
    /**
     * Renders the indexView.
     * 
     * @param db
     * @param consoleMessage to be rendered in console, leave null if not needed
     */
    public static void renderSelected(TodoListDB db, String consoleMessage, List<Task> tasks, List<Event> events) {
        IndexView view = UiManager.loadView(IndexView.class);
        
        if (tasks != null) {
            view.tasks = tasks;
        }
        
        if (events != null) {
            view.events = events;
        }
        view.tags = db.getTagList();
        UiManager.renderView(view);
        
        if (consoleMessage != null) {
            UiManager.updateConsoleMessage(consoleMessage);
        }
    }
    
    /**
     * Renders the indexView.
     * 
     * @param db
     * @param consoleMessage to be rendered in console, leave null if not needed
     */
    public static void renderIndex(TodoListDB db, String consoleMessage) {
        IndexView view = UiManager.loadView(IndexView.class);
        view.tasks = db.getIncompleteTasksAndTaskFromTodayDate();
        view.events = db.getAllCurrentEvents();
        view.tags = db.getTagList();
        UiManager.renderView(view);
        
        if (consoleMessage != null) {
            UiManager.updateConsoleMessage(consoleMessage);
        }
    }
    
    /**
     * Renders the ConfigView.
     * 
     * @param consoleMessage to be rendered in console, leave null if not needed
     */
    public static void renderConfig(String consoleMessage) {
        ConfigView view = UiManager.loadView(ConfigView.class);
        UiManager.renderView(view);
        
        if (consoleMessage != null) {
            UiManager.updateConsoleMessage(consoleMessage);
        }
    }
    
    public static void renderAlias(String consoleMessage) {
        AliasView view = UiManager.loadView(AliasView.class);
        UiManager.renderView(view);
        
        if (consoleMessage != null) {
            UiManager.updateConsoleMessage(consoleMessage);
        }
    }

}
```
###### \java\seedu\todo\controllers\concerns\Tokenizer.java
``` java
/**
 * Class to store the static method <code>tokenizer</code>.
 */
public class Tokenizer {

    private static final String MESSAGE_UNMATCHED_QUOTES = "Unmatched double-quotes detected.";
    private final static String QUOTE = "\"";

    /**
     * A private class to tag a string as a token or a quote.
     */
    private static class TokenizedString {
        public String string;
        public boolean isToken;
        public boolean isQuote;

        TokenizedString(String string, boolean isToken, boolean isQuote) {
            this.string = string;
            this.isToken = isToken;
            this.isQuote = isQuote;
        }

        @Override
        public String toString() {
            return String.format("TokenizedString(%s, %s, %s)", this.string, isToken, isQuote);
        }
    }

    /**
     * Parses and tokenizes a user-input string into a mapping of tokenType -> tokenField.
     * <ul>
     *   <li>Quoted chunks are kept as a whole and never matched to a token.</li>
     *   <li>If there are multiple token matches, only the first one will be registered.</li>
     *   <li>If there are multiple tokenType matches, only one match will be returned.</li>
     * </ul>
     * @param tokenDefinitions  Mapping of tokenType -> list of token strings to match
     * @param inputCommand      User input to tokenize
     * @return                  Mapping of tokenType -> { matchedToken, tokenField }
     * @throws UnmatchedQuotesException If there is an odd number of quotes
     */
    public static Map<String, String[]> tokenize(Map<String, String[]> tokenDefinitions, String inputCommand)
            throws UnmatchedQuotesException {
        
        if (inputCommand.length() == 0) {
            return null;
        }
        
        if (StringUtils.countMatches(inputCommand, QUOTE) % 2 == 1) {
            throw new UnmatchedQuotesException(MESSAGE_UNMATCHED_QUOTES);
        }
        
        // Generate token -> tokenType mapping and list of tokens
        List<String> tokens = new ArrayList<String>();
        HashMap<String, String> getTokenType = new HashMap<String, String>();
        for (Map.Entry<String, String[]> tokenDefinition : tokenDefinitions.entrySet()) {
            String tokenType = tokenDefinition.getKey();
            for (String token : tokenDefinition.getValue()) {
                tokens.add(token);
                getTokenType.put(token, tokenType);
            }
        }

        // Split inputCommand into arraylist of chunks
        // --- Split by quotes
        List<TokenizedString> tokenizedSplitString = tokenizeQuotes(inputCommand);
        
        // --- Split by tokens
        Map<String, Integer> tokenIndices = splitByTokens(tokens, getTokenType, tokenizedSplitString);
        
        // Get arraylist of indices
        // Get dictionary of tokenType -> index
        // Return dictionary of tokenType -> {token, tokenField}
        return constructParsedResult(tokenizedSplitString, tokenIndices);
    }

    /**
     * Given a string, extract quoted substrings and flag them as quotes.
     * 
     * @param inputCommand
     * @return List of TokenizedString
     */
    private static List<TokenizedString> tokenizeQuotes(String inputCommand) {
        String[] splitString = inputCommand.split(QUOTE);

        // If first char is QUOTE, then first element is a quoted string.
        List<TokenizedString> tokenizedSplitString = new ArrayList<TokenizedString>();
        for (int i = 0; i < splitString.length; i++) {
            tokenizedSplitString.add(new TokenizedString(splitString[i].trim(), false, (i % 2 == 1)));
        }
        return tokenizedSplitString;
    }

    /**
     * Constructs the parsedResult from user input that has been delimited and tokenized.
     * @param tokenizedSplitString
     * @param tokenIndices
     * @return parsedResult
     */
    private static Map<String, String[]> constructParsedResult(List<TokenizedString> tokenizedSplitString,
            Map<String, Integer> tokenIndices) {
        Map<String, String[]> parsedResult = new HashMap<String, String[]>();
        for (Map.Entry<String, Integer> tokenIndex : tokenIndices.entrySet()) {
            String tokenType = tokenIndex.getKey();
            String token = tokenizedSplitString.get(tokenIndex.getValue()).string;
            String tokenField = null;
            // Should just EAFP instead of LBYL, but oh well.
            if (tokenIndexPresent(tokenIndex, tokenizedSplitString)) {
                tokenField = tokenizedSplitString.get(tokenIndex.getValue() + 1).string;
            }
            parsedResult.put(tokenType, new String[] { token, tokenField });
        }
        return parsedResult;
    }
    
    /**
     * Checks if an identified tokenIndex contains any data immediately after the token.
     * 
     * @param tokenIndex
     * @param tokenizedSplitString
     * @return true if data is present, false otherwise
     */
    private static boolean tokenIndexPresent(Map.Entry<String, Integer> tokenIndex, List<TokenizedString> tokenizedSplitString) {
        return tokenIndex.getValue() + 1 < tokenizedSplitString.size()
                && !tokenizedSplitString.get(tokenIndex.getValue() + 1).isToken;
    }

    /**
     * Re-implementation from scratch of
     * <code>tokens.split("token1|token2|token3|...")</code> with the constraint
     * that quoted strings are kept intact and unmatched.
     * 
     * @param tokens
     *            List of tokens to match
     * @param getTokenType
     *            Mapping of token -> tokenType
     * @param tokenizedSplitString
     *            User input with quoted strings tagged. This method will modify
     *            tokenizedSplitString in-place.
     * @return Indexes of matched tokens
     */
    private static Map<String, Integer> splitByTokens(List<String> tokens, HashMap<String, String> getTokenType,
            List<TokenizedString> tokenizedSplitString) {
        Map<String, Integer> tokenIndices = new HashMap<String, Integer>();
        for (int i = 0; i < tokenizedSplitString.size(); i++) { // Java doesn't eager-evaluate the terminating condition
            TokenizedString currString = tokenizedSplitString.get(i);
            if (currString.isQuote) {
                continue;
            }
            
            // Record token.
            if (currString.isToken) {
                tokenIndices.put(getTokenType.get(currString.string), i);
                tokens.remove(currString.string);
                continue;
            }
            
            // Try to match all the tokens
            for (String token : tokens) {
                Matcher m = Pattern.compile(String.format("\\b%s\\b", token), Pattern.CASE_INSENSITIVE)
                        .matcher(currString.string);
                if (!m.find()) {
                    continue;
                }
                
                // Found. Replace current element with split elements.
                String preString = currString.string.substring(0, m.start()).trim();
                String postString = currString.string.substring(m.end(), currString.string.length()).trim();
                
                tokenizedSplitString.remove(i);
                List<TokenizedString> replacedSplitStrings = new ArrayList<TokenizedString>();
                if (!preString.isEmpty()) {
                    replacedSplitStrings.add(new TokenizedString(preString, false, false));
                }
                replacedSplitStrings.add(new TokenizedString(token, true, false));
                if (!postString.isEmpty()) {
                    replacedSplitStrings.add(new TokenizedString(postString, false, false));
                }
                tokenizedSplitString.addAll(i, replacedSplitStrings);
                
                // Restart outer loop at current index.
                i--;
                break;
            }   
        }
        return tokenIndices;
    }

}

```
###### \java\seedu\todo\controllers\Controller.java
``` java
/**
 * Contains the logic required to appropriately interpret and process user input
 * from the views.
 */
public abstract class Controller {
    
    public abstract CommandDefinition getCommandDefinition();
    
    /**
     * Given a command keyword, performs a case-insensitive match.
     * 
     * @param keyword       Keyword to match
     * @return confidence   True if the command keyword matches.
     */
    public boolean matchCommandKeyword(String keyword) {
        return getCommandDefinition().getCommandKeyword().equalsIgnoreCase(keyword);
    }
    
    /**
     * Processes the user input.
     * 
     * @param input
     *            User input
     */
    public abstract void process(String input) throws ParseException;

}
```
###### \java\seedu\todo\controllers\DestroyController.java
``` java
/**
 * Controller to destroy a CalendarItem.
 */
public class DestroyController extends Controller {
    
    private static final String DESTROY_TEMPLATE = "destroy %d";
    private static final String NAME = "Destroy";
    private static final String DESCRIPTION = "Destroys a task/event by listed index";
    private static final String COMMAND_SYNTAX = "destroy <index>";
    private static final String COMMAND_KEYWORD = "destroy";
    
    public static final String MESSAGE_DELETE_SUCCESS = "Item deleted successfully!\n" + "To undo, type \"undo\".";
    public static final String MESSAGE_INDEX_OUT_OF_RANGE = "Could not delete task/event: Invalid index provided!";
    public static final String MESSAGE_MISSING_INDEX = "Please specify the index of the item to delete.";
    public static final String MESSAGE_INDEX_NOT_NUMBER = "Index has to be a number!";
    
    private static CommandDefinition commandDefinition =
            new CommandDefinition(NAME, DESCRIPTION, COMMAND_SYNTAX, COMMAND_KEYWORD); 

    @Override
    public CommandDefinition getCommandDefinition() {
        return commandDefinition;
    }

    @Override
    public void process(String args) {
        // Extract param
        String param = args.replaceFirst("destroy", "").trim();
        
        if (param.length() <= 0) {
            Renderer.renderDisambiguation(COMMAND_SYNTAX, MESSAGE_MISSING_INDEX);
            return;
        }
        
        assert param.length() > 0;
        
        // Get index.
        int index = 0;
        try {
            index = Integer.decode(param);
        } catch (NumberFormatException e) {
            Renderer.renderDisambiguation(COMMAND_SYNTAX, MESSAGE_INDEX_NOT_NUMBER);
            return;
        }
        
        // Get record
        EphemeralDB edb = EphemeralDB.getInstance();
        CalendarItem calendarItem = edb.getCalendarItemsByDisplayedId(index);
        TodoListDB db = TodoListDB.getInstance();
        
        if (calendarItem == null) {
            Renderer.renderDisambiguation(String.format(DESTROY_TEMPLATE, index), MESSAGE_INDEX_OUT_OF_RANGE);
            return;
        }
        
        assert calendarItem != null;
        
        if (calendarItem instanceof Task) {
            db.destroyTask((Task) calendarItem);
        } else {
            db.destroyEvent((Event) calendarItem);
        }
        
        // Re-render
        Renderer.renderIndex(db, MESSAGE_DELETE_SUCCESS);
    }

}
```
###### \java\seedu\todo\controllers\FindController.java
``` java
/**
 * Controller to find task/event by keyword
 */
public class FindController extends Controller {

    private static final String NAME = "Find";
    private static final String DESCRIPTION = "Find tasks and events based on the provided keyword.";
    private static final String COMMAND_SYNTAX = "find [name]";
    private static final String COMMAND_KEYWORD = "find";

    public static final String MESSAGE_LISTING_SUCCESS = "A total of %s %s and %s %s found!";
    public static final String MESSAGE_LISTING_FAILURE = "No tasks or events found!";
    public static final String STRING_SPACE = " ";

    private static CommandDefinition commandDefinition = new CommandDefinition(NAME, DESCRIPTION, COMMAND_SYNTAX,
            COMMAND_KEYWORD);

    @Override
    public CommandDefinition getCommandDefinition() {
        return commandDefinition;
    }

    @Override
    public void process(String input) throws ParseException {
        input = input.replaceFirst(COMMAND_KEYWORD, "").trim();
        List<String> namesToFind = Arrays.asList(input.split(STRING_SPACE));

        List<Predicate<Task>> taskPredicates = new ArrayList<Predicate<Task>>();
        taskPredicates.add(Task.predByNameAny(namesToFind));
        List<Task> tasks = Task.where(taskPredicates);

        List<Predicate<Event>> eventPredicates = new ArrayList<Predicate<Event>>();
        eventPredicates.add(Event.predByNameAny(namesToFind));
        List<Event> events = Event.where(eventPredicates);

        if (tasks.size() == 0 && events.size() == 0) {
            Renderer.renderIndex(TodoListDB.getInstance(), MESSAGE_LISTING_FAILURE);
        } else {
            String consoleMessage = String.format(MESSAGE_LISTING_SUCCESS, tasks.size(),
                    StringUtil.pluralizer(tasks.size(), "task", "tasks"), events.size(),
                    StringUtil.pluralizer(events.size(), "event", "events"));
            Renderer.renderSelected(TodoListDB.getInstance(), consoleMessage, tasks, events);
        }
    }
}
```
###### \java\seedu\todo\controllers\RedoController.java
``` java
/**
 * Controller to redo a database commit.
 */
public class RedoController extends Controller {

    private static final String NAME = "Redo";
    private static final String DESCRIPTION = "Redo your last undo(s).";
    private static final String COMMAND_SYNTAX = "redo <times>";
    private static final String COMMAND_KEYWORD = "redo";
    private static final String REDO_TEMPLATE = "redo %s";
    private static final String INDEX_FIELD = "<index>";
    
    private static final String MESSAGE_SUCCESS = "Successfully redid %s %s!\nTo undo, type \"undo\".";
    private static final String MESSAGE_MULTIPLE_FAILURE = "We cannot redo %s %s! At most, you can redo %s %s.";
    private static final String MESSAGE_FAILURE = "There is no command to redo!";
    private static final String MESSAGE_INDEX_NOT_NUMBER = "Index has to be a number!";
    
    private static CommandDefinition commandDefinition =
            new CommandDefinition(NAME, DESCRIPTION, COMMAND_SYNTAX, COMMAND_KEYWORD); 

    @Override
    public CommandDefinition getCommandDefinition() {
        return commandDefinition;
    }
    
    /**
     * Get the token definitions for use with <code>tokenizer</code>.<br>
     * This method exists primarily because Java does not support HashMap
     * literals...
     * 
     * @return tokenDefinitions
     */
    private static Map<String, String[]> getTokenDefinitions() {
        Map<String, String[]> tokenDefinitions = new HashMap<String, String[]>();
        tokenDefinitions.put("default", new String[] {"redo"});
        return tokenDefinitions;
    }

    @Override
    public void process(String input) throws ParseException {
        
        Map<String, String[]> parsedResult;
        parsedResult = Tokenizer.tokenize(getTokenDefinitions(), input);
        
        int numRedo = 1;
        if (parsedResult.get("default")[1] != null) {
            try {
                numRedo = Integer.decode(parsedResult.get("default")[1]);
            } catch (NumberFormatException e) {
                Renderer.renderDisambiguation(String.format(REDO_TEMPLATE, INDEX_FIELD), MESSAGE_INDEX_NOT_NUMBER);
                return;
            }
        }
        
        // We don't really have a nice way to support SQL transactions, so yeah >_<
        TodoListDB db = TodoListDB.getInstance();
        
        // Attempt to redo DB. If fail, exit method.
        if (!attemptRedo(numRedo, db)) {
            return;
        }
        
        // Reload DB
        db = TodoListDB.getInstance();
        
        // Render
        Renderer.renderIndex(db, String.format(MESSAGE_SUCCESS, numRedo,
                StringUtil.pluralizer(numRedo, "command", "commands")));
    }

    /**
     * Attempt to redo the DB by <code>numRedo</code> steps. If this fails, this
     * method will update the console message with appropriate error messages.
     * 
     * @param numRedo   Number of steps to redo
     * @param db        TodoListDB instance
     * @return          true if redo attempt successful, false otherwise
     */
    private boolean attemptRedo(int numRedo, TodoListDB db) {
        if (numRedo <= 0 || db.redoSize() <= 0) {
            UiManager.updateConsoleMessage(MESSAGE_FAILURE);
            return false;
        }
        if (db.redoSize() < numRedo) {
            UiManager.updateConsoleMessage(String.format(MESSAGE_MULTIPLE_FAILURE,
                    numRedo, StringUtil.pluralizer(numRedo, "command", "commands"),
                    db.redoSize(), StringUtil.pluralizer(db.redoSize(), "command", "commands")));
            return false;
        }
        for (int i = 0; i < numRedo; i++) {
            if (!db.redo()) {
                UiManager.updateConsoleMessage(MESSAGE_FAILURE);
                return false;
            }
        }
        return true;
    }
}
```
###### \java\seedu\todo\controllers\UnaliasController.java
``` java
/**
 * Controller to unalias an existing alias.
 */
public class UnaliasController extends Controller {
    
    private static final String NAME = "Unalias";
    private static final String DESCRIPTION = "Deletes an existing alias pair.";
    private static final String COMMAND_SYNTAX = "unalias <alias key>";
    private static final String COMMAND_KEYWORD = "unalias";
    
    private static final String MESSAGE_DESTROY_SUCCESS = "Successfully destroyed alias!";
    private static final String MESSAGE_INVALID_INPUT = "Invalid alias parameters! Alias inputs must consist solely "
            + "of alphabetical characters.";
    private static final String MESSAGE_ALIAS_NOT_EXISTS = "Specified alias key doesn't exist!";
    private static final String SAVE_ERROR = "There was an error saving your aliases. Please try again.";
    
    private static CommandDefinition commandDefinition =
            new CommandDefinition(NAME, DESCRIPTION, COMMAND_SYNTAX, COMMAND_KEYWORD); 

    @Override
    public CommandDefinition getCommandDefinition() {
        return commandDefinition;
    }

    @Override
    public void process(String input) throws ParseException {
        String aliasKey = input.replaceFirst("unalias", "").trim();
        
        if (aliasKey.isEmpty() || !validateAlias(aliasKey)) {
            renderDisambiguation(aliasKey, MESSAGE_INVALID_INPUT);
            return;
        }
        
        // Persist alias mapping
        try {
            if (destroyAlias(aliasKey)) {
                Renderer.renderAlias(MESSAGE_DESTROY_SUCCESS);
            } else {
                renderDisambiguation(aliasKey, MESSAGE_ALIAS_NOT_EXISTS);
            }
        } catch (IOException e) {
            Renderer.renderAlias(SAVE_ERROR);
            return;
        }
    }
    
    private static boolean destroyAlias(String aliasKey) throws IOException {
        Config config = ConfigCenter.getInstance().getConfig();
        Map<String, String> aliases = config.getAliases();
        if (aliases.remove(aliasKey) == null) {
            return false;
        }
        ConfigCenter.getInstance().saveConfig(config);
        return true;
    }
    
    /**
     * Validates that string is sanitized and safe for aliasing.
     * 
     * @param alias     string to check
     * @return          true if string is sanitized, false otherwise
     */
    private static boolean validateAlias(String alias) {
        return alias.chars().allMatch(Character::isLetter);
    }
    
    private static void renderDisambiguation(String aliasKey, String message) {
        String sanitizedAliasKey = StringUtil.sanitize(aliasKey);
        sanitizedAliasKey = StringUtil.replaceEmpty(sanitizedAliasKey, "<alias key>");
        Renderer.renderDisambiguation(String.format("unalias \"%s\"", sanitizedAliasKey), message);
    }

}
```
###### \java\seedu\todo\controllers\UndoController.java
``` java
/**
 * Controller to undo a database commit.
 */
public class UndoController extends Controller {

    private static final String NAME = "Undo";
    private static final String DESCRIPTION = "Undo your last action(s) to the list of tasks/events.";
    private static final String COMMAND_SYNTAX = "undo <times>";
    private static final String COMMAND_KEYWORD = "undo";
    private static final String UNDO_TEMPLATE = "undo %s";
    private static final String INDEX_FIELD = "<index>";
    
    private static final String MESSAGE_SUCCESS = "Successfully undid %s %s!\nTo redo, type \"redo\".";
    private static final String MESSAGE_MULTIPLE_FAILURE = "We cannot undo %s %s! At most, you can undo %s %s.";
    private static final String MESSAGE_FAILURE = "There is no command to undo!";
    private static final String MESSAGE_INDEX_NOT_NUMBER = "Index has to be a number!";
    
    private static CommandDefinition commandDefinition =
            new CommandDefinition(NAME, DESCRIPTION, COMMAND_SYNTAX, COMMAND_KEYWORD); 

    @Override
    public CommandDefinition getCommandDefinition() {
        return commandDefinition;
    }
    
    /**
     * Get the token definitions for use with <code>tokenizer</code>.<br>
     * This method exists primarily because Java does not support HashMap
     * literals...
     * 
     * @return tokenDefinitions
     */
    private static Map<String, String[]> getTokenDefinitions() {
        Map<String, String[]> tokenDefinitions = new HashMap<String, String[]>();
        tokenDefinitions.put("default", new String[] {"undo"});
        return tokenDefinitions;
    }

    @Override
    public void process(String input) throws ParseException {
        
        Map<String, String[]> parsedResult;
        parsedResult = Tokenizer.tokenize(getTokenDefinitions(), input);
        
        int numUndo = 1;
        if (parsedResult.get("default")[1] != null) {
            try {
                numUndo = Integer.decode(parsedResult.get("default")[1]);
            } catch (NumberFormatException e) {
                Renderer.renderDisambiguation(String.format(UNDO_TEMPLATE, INDEX_FIELD), MESSAGE_INDEX_NOT_NUMBER);
                return;
            }
        }
        
        // We don't really have a nice way to support SQL transactions, so yeah >_<
        TodoListDB db = TodoListDB.getInstance();
        
        // Attempt to undo DB. If fail, exit method.
        if (!attemptUndo(numUndo, db)) {
            return;
        }
        
        // Reload DB
        db = TodoListDB.getInstance();
        
        // Render
        Renderer.renderIndex(db, String.format(MESSAGE_SUCCESS, numUndo,
                StringUtil.pluralizer(numUndo, "command", "commands")));
    }
    
    /**
     * Attempt to undo the DB by <code>numUndo</code> steps. If this fails, this
     * method will update the console message with appropriate error messages.
     * 
     * @param numUndo   Number of steps to undo
     * @param db        TodoListDB instance
     * @return          true if undo attempt successful, false otherwise
     */
    private boolean attemptUndo(int numUndo, TodoListDB db) {
        if (numUndo <= 0 || db.undoSize() <= 0) {
            UiManager.updateConsoleMessage(MESSAGE_FAILURE);
            return false;
        }
        if (db.undoSize() < numUndo) {
            UiManager.updateConsoleMessage(String.format(MESSAGE_MULTIPLE_FAILURE,
                    numUndo, StringUtil.pluralizer(numUndo, "command", "commands"),
                    db.undoSize(), StringUtil.pluralizer(db.undoSize(), "command", "commands")));
            return false;
        }
        for (int i = 0; i < numUndo; i++) {
            if (!db.undo()) {
                UiManager.updateConsoleMessage(MESSAGE_FAILURE);
                return false;
            }
        }
        return true;
    }
}
```
###### \java\seedu\todo\controllers\UpdateController.java
``` java
/**
 * Controller to update a CalendarItem.
 */
public class UpdateController extends Controller {

    private static final String NAME = "Update";
    private static final String DESCRIPTION = "Updates a task by listed index.";
    private static final String COMMAND_SYNTAX = "update <index> <task> by <deadline>";
    private static final String COMMAND_KEYWORD = "update";

    public static final String MESSAGE_UPDATE_SUCCESS = "Item successfully updated!";
    public static final String MESSAGE_INVALID_ITEM_OR_PARAM = "Please specify a valid index and parameter to update!";
    public static final String MESSAGE_CANNOT_PARSE_DATE = "We could not parse the date in your previous command, please correct it.";
    
    public static final String STRING_NULL = "null";
    public static final String UPDATE_EVENT_TEMPLATE = "update %s [name \"%s\"] [from \"%s\" to \"%s\"]";
    public static final String UPDATE_TASK_TEMPLATE = "update %s [name \"%s\"] [by \"%s\"]";
    public static final String START_TIME_FIELD = "<start time>";
    public static final String END_TIME_FIELD = "<end time>";
    public static final String DEADLINE_FIELD = "<deadline / null>";
    public static final String NAME_FIELD = "<name>";
    public static final String INDEX_FIELD = "<index>";

    private static CommandDefinition commandDefinition = new CommandDefinition(NAME, DESCRIPTION, COMMAND_SYNTAX, COMMAND_KEYWORD);

    @Override
    public CommandDefinition getCommandDefinition() {
        return commandDefinition;
    }

    /**
     * Get the token definitions for use with <code>tokenizer</code>.<br>
     * This method exists primarily because Java does not support HashMap
     * literals...
     * 
     * @return tokenDefinitions
     */
    private static Map<String, String[]> getTokenDefinitions() {
        Map<String, String[]> tokenDefinitions = new HashMap<String, String[]>();
        tokenDefinitions.put("default", new String[] { "update" });
        tokenDefinitions.put("name", new String[] { "name" });
        tokenDefinitions.put("time", new String[] { "at", "by", "on", "before", "time" });
        tokenDefinitions.put("timeFrom", new String[] { "from" });
        tokenDefinitions.put("timeTo", new String[] { "to" });
        return tokenDefinitions;
    }

    @Override
    public void process(String input) throws ParseException {
        Map<String, String[]> parsedResult;
        parsedResult = Tokenizer.tokenize(getTokenDefinitions(), input);

        // Name
        String name = parseName(parsedResult);

        // Time
        String[] naturalDates = DateParser.extractDatePair(parsedResult);
        String naturalFrom = naturalDates[0];
        String naturalTo = naturalDates[1];

        // Record index
        Integer recordIndex = parseIndex(parsedResult);

        // Retrieve record and check if task or event
        EphemeralDB edb = EphemeralDB.getInstance();
        CalendarItem calendarItem = null;
        boolean isTask;
        try {
            calendarItem = edb.getCalendarItemsByDisplayedId(recordIndex);
            isTask = calendarItem.getClass() == Task.class;
        } catch (NullPointerException e) {
            // Assume task for disambiguation purposes since we can't tell
            renderDisambiguation(true, recordIndex, name, naturalFrom, naturalTo, MESSAGE_INVALID_ITEM_OR_PARAM);
            return;
        }

        // Parse natural date using Natty.
        LocalDateTime dateFrom = null;
        LocalDateTime dateTo = null;
        try {
            // Allow exception for "null"
            dateFrom = (naturalFrom == null || STRING_NULL.equals(naturalFrom.trim()))
                    ? null : DateParser.parseNatural(naturalFrom);
            dateTo = naturalTo == null ? null : DateParser.parseNatural(naturalTo);
        } catch (InvalidNaturalDateException e) {
            renderDisambiguation(isTask, recordIndex, name, naturalFrom, naturalTo, MESSAGE_CANNOT_PARSE_DATE);
            return;
        }

        // Validate isTask, name and times.
        if (!validateParams(isTask, calendarItem, name, dateFrom, dateTo, naturalFrom)) {
            renderDisambiguation(isTask, (int) recordIndex, name, naturalFrom, naturalTo, null);
            return;
        }

        // Update and persist task / event.
        TodoListDB db = TodoListDB.getInstance();
        updateCalendarItem(db, calendarItem, isTask, name, dateFrom, dateTo, naturalFrom);

        // Re-render
        Renderer.renderIndex(db, MESSAGE_UPDATE_SUCCESS);
    }

    /**
     * Extracts the record index from parsedResult.
     * 
     * @param parsedResult
     * @return Integer index if parse was successful, null otherwise.
     */
    private Integer parseIndex(Map<String, String[]> parsedResult) {
        String indexStr = null;
        try {
            if (parsedResult.get("default") != null && parsedResult.get("default")[1] != null) {
                indexStr = parsedResult.get("default")[1].trim();
                return Integer.decode(indexStr);
            }
        } catch (NumberFormatException e) {
            // Everything is fine, just return null if cannot.
        }
        return null;
    }

    /**
     * Extracts the name to be updated from parsedResult.
     * 
     * @param parsedResult
     * @return String name if found, null otherwise.
     */
    private String parseName(Map<String, String[]> parsedResult) {
        if (parsedResult.get("name") != null && parsedResult.get("name")[1] != null) {
            return parsedResult.get("name")[1];
        }
        return null;
    }

    /**
     * Updates and persists a CalendarItem to the DB.
     * 
     * @param db
     *            TodoListDB instance
     * @param record
     *            Record to update
     * @param isTask
     *            true if CalendarItem is a Task, false if Event
     * @param name
     *            Display name of CalendarItem object
     * @param dateFrom
     *            Due date for Task or start date for Event
     * @param dateTo
     *            End date for Event
     */
    private void updateCalendarItem(TodoListDB db, CalendarItem record, boolean isTask, String name,
            LocalDateTime dateFrom, LocalDateTime dateTo, String naturalFrom) {
        // Update name if not null
        if (name != null) {
            record.setName(name);
        }

        // Update time
        if (isTask) {
            Task task = (Task) record;
            if (dateFrom != null) {
                task.setDueDate(dateFrom);
            } else if (naturalFrom != null && naturalFrom.trim().equals(STRING_NULL)) {
                task.setDueDate(null);
            }
        } else {
            Event event = (Event) record;
            if (dateFrom != null) {
                event.setStartDate(dateFrom);
            }
            if (dateTo != null) {
                event.setEndDate(dateTo);
            }
        }

        // Persist
        db.save();
    }

    /**
     * Validate that applying the update changes to the record will not result
     * in an inconsistency.
     * 
     * <ul>
     * <li>Fail if name is invalid</li>
     * <li>Fail if no update changes</li>
     * </ul>
     * 
     * Tasks:
     * <ul>
     * <li>Fail if task has a dateTo</li>
     * </ul>
     * 
     * Events:
     * <ul>
     * <li>Fail if event does not have both dateFrom and dateTo</li>
     * <li>Fail if event has a dateTo that is before dateFrom</li>
     * </ul>
     * 
     * @param isTask
     * @param name
     * @param dateFrom
     * @param dateTo
     * @return
     */
    private boolean validateParams(boolean isTask, CalendarItem record, String name, LocalDateTime dateFrom,
            LocalDateTime dateTo, String naturalFrom) {
        // We really need proper ActiveRecord validation and rollback, sigh...

        if (!validateNameDateChange(name, dateFrom, dateTo, naturalFrom)) {
            return false;
        }

        if (isTask) {
            // Fail if task has a dateTo
            if (dateTo != null) {
                return false;
            }
        } else {
            Event event = (Event) record;
            if (!validateUpdatedEventDates(event, dateFrom, dateTo)) {
                return false;
            }
        }
        return true;
    }
    
    /**
     * Checks that there is at least one update param specified.
     * 
     * @param name
     * @param dateFrom
     * @param dateTo
     * @param naturalFrom
     * @return
     */
    private boolean validateNameDateChange(String name, LocalDateTime dateFrom, LocalDateTime dateTo, String naturalFrom) {
        return !(name == null && dateFrom == null && dateTo == null
                && !STRING_NULL.equals(naturalFrom));
    }
    
    /**
     * Validates an event to be updated with dateFrom and dateTo.
     * 
     * @param oldEvent
     * @param dateFrom
     * @param dateTo
     * @return
     */
    private boolean validateUpdatedEventDates(Event oldEvent, LocalDateTime dateFrom, LocalDateTime dateTo) {
        // Take union of existing fields and update params
        LocalDateTime newDateFrom = (dateFrom == null) ? oldEvent.getStartDate() : dateFrom;
        LocalDateTime newDateTo = (dateTo == null) ? oldEvent.getEndDate() : dateTo;

        return (newDateFrom != null && newDateTo != null && !newDateTo.isBefore(newDateFrom));
    }

    /**
     * Disambiguate an ambiguous input by auto-populating a templated command on
     * a best-effort basis.
     * 
     * @param isTask
     * @param name
     * @param naturalFrom
     * @param naturalTo
     * @param errorMessage
     */
    private void renderDisambiguation(boolean isTask, Integer recordIndex, String name, String naturalFrom,
            String naturalTo, String errorMessage) {
        name = StringUtil.replaceEmpty(name, NAME_FIELD);

        String disambiguationString;
        String indexStr = (recordIndex == null) ? INDEX_FIELD : recordIndex.toString();

        if (isTask) {
            naturalFrom = StringUtil.replaceEmpty(naturalFrom, DEADLINE_FIELD);
            disambiguationString = String.format(UPDATE_TASK_TEMPLATE, indexStr, name, naturalFrom);
        } else {
            naturalFrom = StringUtil.replaceEmpty(naturalFrom, START_TIME_FIELD);
            naturalTo = StringUtil.replaceEmpty(naturalTo, END_TIME_FIELD);
            disambiguationString = String.format(UPDATE_EVENT_TEMPLATE, indexStr, name, naturalFrom, naturalTo);
        }

        // Show an error in the console
        Renderer.renderDisambiguation(disambiguationString, errorMessage);
    }
}
```
###### \java\seedu\todo\models\CalendarItem.java
``` java
/**
 * CalendarItem interface
 */
public interface CalendarItem {
    
    /**
     * Get the display name of the calendar item.
     * @return name
     */
    public String getName();
    
    /**
     * Set the display name of the calendar item.
     * @param name
     */
    public void setName(String name);

    /**
     * Get the calendar date of the calendar item. This is mostly for display
     * and sorting purposes.
     * 
     * @return datetime
     */
    public LocalDateTime getCalendarDateTime();
    
    /**
     * Set the calendar date of the calendar item. The behavior of this will
     * depend on the implementation, but it is guaranteed that the variable
     * being set by this method is the variable that is returned by
     * <code>getCalendarDT()</code>.<br>
     * 
     * It is unclear why one would ever set a calendar item's datetime using
     * this method, but it is here for completeness.
     * 
     * @param datetime
     */
    public void setCalendarDateTime(LocalDateTime datetime);
    
    /**
     * Returns true if the calendar item has passed, false otherwise.
     * 
     * @return isOver
     */
    public boolean isOver();
    
    /**
     * Returns the current tag list that belong to the CalendarItem, mainly for displaying purpose
     * 
     * @return ArrayList<String> tags
```
###### \java\seedu\todo\models\Event.java
``` java
/**
 * Event model
 */
public class Event implements CalendarItem {
    
    private String name;
    private LocalDateTime startDate;
    private LocalDateTime endDate;
    private ArrayList<String> tagList = new ArrayList<String>();
    
    public static final int MAX_TAG_LIST_SIZE = 20;
    
    /**
     * Get the start date of an Event.
     * @return startDate
     */
    public LocalDateTime getStartDate() {
        return startDate;
    }

    /**
     * Set the start date of an Event.
     * @param startDate
     */
    public void setStartDate(LocalDateTime startDate) {
        this.startDate = startDate;
    }

    /**
     * Get the end date of an Event.
     * @return endDate
     */
    public LocalDateTime getEndDate() {
        return endDate;
    }

    /**
     * Set the end date of an Event.
     * @param endDate
     */
    public void setEndDate(LocalDateTime endDate) {
        this.endDate = endDate;
    }

    @Override
    public String getName() {
        return this.name;
    }

    @Override
    public void setName(String name) {
        this.name = name;
    }

    @Override
    public LocalDateTime getCalendarDateTime() {
        return getStartDate(); 
    }

    @Override
    public void setCalendarDateTime(LocalDateTime datetime) {
        setStartDate(datetime);
    }
    
    @Override
    public boolean isOver() {
        if (endDate == null) {
            return false;
        } else {
            return endDate.isBefore(LocalDateTime.now());
        }
    }

    @Override
```
###### \java\seedu\todo\models\Event.java
``` java
     * 
     * Filtering methods intended to replace hacky one-filter-method-per-permutation from Yaocong.
     * Seriously, why??!!
     */
    public static List<Event> where(List<Predicate<Event>> predicates) {
        List<Event> result = TodoListDB.getInstance().getAllEvents();
        for (Predicate<Event> predicate : predicates) {
            filter(predicate, result);
        }
        return result;
    }
    
    public static Predicate<Event> predByName(String name) {
        return (Event event) -> Pattern.compile(String.format("\\b%s", name), Pattern.CASE_INSENSITIVE)
                .matcher(event.getName()).find();
    }
    
    public static Predicate<Event> predByNameAny(List<String> names) {
        return (Event event) -> {
            for (String name : names) {
                if (predByName(name).test(event)) {
                    return true;
                }
            }
            return false;
        };
    }
    
    public static Predicate<Event> predStartBefore(LocalDateTime date) {
        return (Event event) -> event.getStartDate().isBefore(date);
    }
    
    public static Predicate<Event> predStartAfter(LocalDateTime date) {
        return (Event event) -> event.getStartDate().isAfter(date);
    }
    
    public static Predicate<Event> predEndBefore(LocalDateTime date) {
        return (Event event) -> event.getEndDate().isBefore(date);
    }
    
    public static Predicate<Event> predEndAfter(LocalDateTime date) {
        return (Event event) -> event.getEndDate().isAfter(date);
    }
    
    public static Predicate<Event> predTag(String tag) {
        return (Event event) -> {
            for (String currTag : event.getTagList()) {
                if (currTag.toLowerCase().equals(tag.toLowerCase())) {
                    return true;
                }
            }
            return false;
        };
    }
    
    public static void filter(Predicate<Event> predicate, List<Event> eventList) {
        for (int i = eventList.size() - 1; i >= 0; i--) {
            if (!predicate.test(eventList.get(i))) {
                eventList.remove(i);
            }
        }
    }

}
```
###### \java\seedu\todo\models\Task.java
``` java
/**
 * Task model
 */
public class Task implements CalendarItem {
    
    private String name;
    private LocalDateTime dueDate;
    private boolean isCompleted = false;
    private ArrayList<String> tagList = new ArrayList<String>();
    
    public static final int MAX_TAG_LIST_SIZE = 20;

    @Override
    public String getName() {
        return name;
    }

    @Override
    public void setName(String name) {
        this.name = name;
    }

    /**
     * Get the due date of a Task.
     * @return dueDate
     */
    public LocalDateTime getDueDate() {
        return dueDate;
    }

    /**
     * Set the due date of a Task.
     * @param dueDate
     */
    public void setDueDate(LocalDateTime dueDate) {
        this.dueDate = dueDate;
    }
    
    @Override
    public LocalDateTime getCalendarDateTime() {
        return getDueDate();
    }
    
    @Override
    public void setCalendarDateTime(LocalDateTime date) {
        setDueDate(date);
    }
    
    @Override
    public boolean isOver() {
        if (dueDate == null) {
            return false;
        } else {
            return dueDate.isBefore(LocalDateTime.now());
        }
    }

    /**
     * Returns true if the Task is completed, false otherwise.
     * @return isCompleted
     */
    public boolean isCompleted() {
        return isCompleted;
    }
    
    /**
     * Marks a Task as completed.
     */
    public void setCompleted() {
        this.isCompleted = true;
    }

    /**
     * Marks a Task as incomplete.
     */
    public void setIncomplete() {
        this.isCompleted = false;
    }

    @Override
```
###### \java\seedu\todo\models\Task.java
``` java
     * 
     * Filtering methods intended to replace hacky one-filter-method-per-permutation from Yaocong.
     * Seriously, why??!!
     */
    public static List<Task> where(List<Predicate<Task>> predicates) {
        List<Task> result = TodoListDB.getInstance().getAllTasks();
        for (Predicate<Task> predicate : predicates) {
            filter(predicate, result);
        }
        return result;
    }
    
    public static Predicate<Task> predByName(String name) {
        return (Task task) -> Pattern.compile(String.format("\\b%s", name), Pattern.CASE_INSENSITIVE)
                .matcher(task.getName()).find();
    }
    
    public static Predicate<Task> predByNameAny(List<String> names) {
        return (Task task) -> {
            for (String name : names) {
                if (predByName(name).test(task)) {
                    return true;
                }
            }
            return false;
        };
    }
    
    public static Predicate<Task> predBeforeDueDate(LocalDateTime date) {
        return (Task task) -> task.getDueDate() != null && task.getDueDate().isBefore(date);
    }
    
    public static Predicate<Task> predAfterDueDate(LocalDateTime date) {
        return (Task task) -> task.getDueDate() != null && task.getDueDate().isAfter(date);
    }
    
    public static Predicate<Task> predCompleted(boolean completed) {
        return (Task task) -> task.isCompleted() == completed;
    }
    
    public static Predicate<Task> predTag(String tag) {
        return (Task task) -> {
            for (String currTag : task.getTagList()) {
                if (currTag.toLowerCase().equals(tag.toLowerCase())) {
                    return true;
                }
            }
            return false;
        };
    }
    
    public static void filter(Predicate<Task> predicate, List<Task> taskList) {
        for (int i = taskList.size() - 1; i >= 0; i--) {
            if (!predicate.test(taskList.get(i))) {
                taskList.remove(i);
            }
        }
    }

}
```
###### \java\seedu\todo\models\TodoListDB.java
``` java
/**
 * This class holds the entire persistent database for the TodoList app.
 * <ul>
 * <li>This is a singleton class. For obvious reasons, the TodoList app should
 * not be working with multiple DB instances simultaneously.</li>
 * <li>Object to object dynamic references should not be expected to survive
 * serialization.</li>
 * </ul>
 */
public class TodoListDB {

    private static TodoListDB instance = null;
    private static Storage storage = new JsonStorage();
    
    private Set<Task> tasks = new LinkedHashSet<Task>();
    private Set<Event> events = new LinkedHashSet<Event>();
    private Map<String, String> aliases = new HashMap<String, String>();
    private Set<String> tagList = new LinkedHashSet<String>();
    
    protected TodoListDB() {
        // Prevent instantiation.
    }
    
    /**
     * Gets the singleton instance of the TodoListDB.
     * 
     * @return TodoListDB
     */
    public static TodoListDB getInstance() {
        if (instance == null) {
            instance = new TodoListDB();
        }
        return instance;
    }
    
    public void setStorage(Storage storageToSet) {
        storage = storageToSet;
    }
    
    /**
     * Update the overall Tags that exist in the DB.
     * 
     */
    public void updateTagList(String tagName) {
        tagList.add(tagName);
    }
    
    /**
     * Get a list of Tags in the DB.
     * 
     * @return tagList
     */
    public List<String> getTagList() {
        return new ArrayList<String>(tagList);
    }
    
    /**
     * Count tags which are already inserted into the db
     * 
     * @return Number of tags
     */
    public int countTagList() {
        return tagList.size();
    }
    
    public Map<String, String> getAliases() {
        return aliases;
    }
    
    /**
     * Get a list of Tasks in the DB.
     * 
     * @return tasks
     */
    public List<Task> getAllTasks() {
        return new ArrayList<Task>(tasks);
    }

    
    /**
     * Count tasks which are not marked as complete, where {@code isComplete} is false.
     * 
     * @return Number of incomplete tasks
     */
    public int countIncompleteTasks() {
        int count = 0;
        for (Task task : tasks) {
            if (!task.isCompleted()) {
                count++;
            }
        }
        return count;
    }
    
    /**
     * Count tasks which are overdue, where {@code dueDate} is before the time now.
     * 
     * @return Number of overdue tasks
     */
    public int countOverdueTasks() {
        LocalDateTime now = LocalDateTime.now();
        int count = 0;
        for (Task task : tasks) {
            LocalDateTime dueDate = task.getDueDate();
            if (!task.isCompleted() && dueDate != null && dueDate.compareTo(now) < 0) {
                count++;
            }
        }
        return count;
    }
    
    /**
     * Get a list of Events in the DB.
     * 
     * @return events
     */
    public List<Event> getAllEvents() {
        return new ArrayList<Event>(events);
    }

    /**
     * Count events which are in the future, where {@code startDate} is after the time now.
     * 
     * @return Number of future events
     */
    public int countFutureEvents() {
        LocalDateTime now = LocalDateTime.now();
        int count = 0;
        for (Event event : events) {
            LocalDateTime startDate = event.getStartDate();
            if (startDate != null && startDate.compareTo(now) >= 0) {
                count++;
            }
        }
        return count;
    }
    
    /**
     * Create a new Task in the DB and return it.<br>
     * <i>The new record is not persisted until <code>save</code> is explicitly
     * called.</i>
     * 
     * @return task
     */
    public Task createTask() {
        Task task = new Task();
        tasks.add(task);
        return task;
    }
    
    /**
     * Destroys a Task in the DB and persists the commit.
     * 
     * @param task
     * @return true if the save was successful, false otherwise
     */
    public boolean destroyTask(Task task) {
        tasks.remove(task);
        return save();
    }
    
    /**
     * Destroys all `tasks` from the DB.
     * 
     * @param tasks Tasks to remove
     */
    public void destroyTasks(List<Task> clearTasks) {
        tasks.removeAll(clearTasks);
    }
    
    /**
```
###### \java\seedu\todo\models\TodoListDB.java
``` java
     * 
     * Create a new Event in the DB and return it.<br>
     * <i>The new record is not persisted until <code>save</code> is explicitly
     * called.</i>
     * 
     * @return event
     */
    public Event createEvent() {
        Event event = new Event();
        events.add(event);
        return event;
    }
    
    /**
     * Destroys an Event in the DB and persists the commit.
     * 
     * @param event
     * @return true if the save was successful, false otherwise
     */
    public boolean destroyEvent(Event event) {
        events.remove(event);
        return save();
    }
    
    /**
     * Destroys all `events` from the DB.
     * 
     * @param tasks Tasks to remove
     */
    public void destroyEvents(List<Event> clearEvents) {
        events.removeAll(clearEvents);
    }
    
    /**
```
###### \java\seedu\todo\models\TodoListDB.java
``` java
     * 
     * Explicitly persists the database to disk.
     * 
     * @return true if the save was successful, false otherwise
     */
    public boolean save() {
        try {
            storage.save(this);
            return true;
        } catch (IOException e) {
            return false;
        }
    }
    
    /**
     * Explicitly reloads the database from disk.
     * 
     * @return true if the load was successful, false otherwise
     */
    public boolean load() {
        try {
            instance = storage.load();
            return true;
        } catch (IOException e) {
            return false;
        }
    }
    
    public void move(String newPath) throws IOException {
        storage.move(newPath);
    }
    
    /**
     * Returns the maximum possible number of undos.
     * 
     * @return undoSize
     */
    public int undoSize() {
        return storage.undoSize();
    }
    
    /**
     * Rolls back the DB by one commit.
     * 
     * @return true if the rollback was successful, false otherwise
     */
    public boolean undo() {
        try {
            instance = storage.undo();
            return true;
        } catch (CannotUndoException | IOException e) {
            return false;
        }
    }
    
    /**
     * Returns the maximum possible number of redos.
     * 
     * @return redoSize
     */
    public int redoSize() {
        return storage.redoSize();
    }
    
    /**
     * Rolls forward the DB by one undo commit.
     * 
     * @return true if the redo was successful, false otherwise
     */
    public boolean redo() {
        try {
            instance = storage.redo();
            return true;
        } catch (CannotRedoException | IOException e) {
            return false;
        }
    }
    
    /**
     * Get a list of events that are not over based on today date from the DB.
     * 
     * @return events
```
###### \java\seedu\todo\storage\JsonStorage.java
``` java
/**
 * JSON Storage for persisting and loading from disk.
 */
public class JsonStorage implements Storage {
    
    // Ideally this would be a single circular-queue, but there is no such built-in
    // mechanism, and we would really really like to keep this operation O(1).
    private Deque<LinkedList<Patch>> historyPatch = new ArrayDeque<LinkedList<Patch>>();
    private Deque<LinkedList<Patch>> futurePatch = new ArrayDeque<LinkedList<Patch>>();
    private String currJson;
    private final static int HISTORY_SIZE = 1000;
    private final DiffMatchPatch dmp = new DiffMatchPatch();

    private File getStorageFile() {
        String filePath = ConfigCenter.getInstance().getConfig().getDatabaseFilePath();
        return new File(filePath);
    }
    
    /**
     * Internal function to prune the history patches stored to ensure it does
     * not exit HISTORY_SIZE.
     */
    private void pruneHistory() {
        // Don't need to worry about future because it cannot exceed limit.
        while (historyPatch.size() > HISTORY_SIZE) {
            historyPatch.removeFirst();
        }
    }
    
    @Override
    public void move(String newPath) throws IOException {
        boolean hasMoved = false;
        
        try {
            FileUtil.createParentDirsOfFile(new File(newPath));
        } catch (IOException e) {
            throw e;
        }
        
        try {
            hasMoved = getStorageFile().renameTo(new File(newPath));
        } catch (SecurityException e) {
            throw new IOException(e.getMessage(), e.getCause());
        }
        
        if (!hasMoved) {
            throw new IOException(String.format("Could not move file to \"%s\".", newPath));
        }
    }

    @Override
    public void save(TodoListDB db) throws JsonProcessingException, IOException {
        String newJson = JsonUtil.toJsonString(db);
        
        // Store the undo patch.
        if (this.currJson != null) {
            historyPatch.addLast(dmp.patchMake(newJson, this.currJson));
            pruneHistory();
            futurePatch.clear(); // A forward move nullifies all future patches.
        }
        
        // Update currJson and persist to disk.
        this.currJson = newJson;
        FileUtil.writeToFile(getStorageFile(), this.currJson);
    }

    @Override
    public TodoListDB load() throws IOException {
        this.currJson = FileUtil.readFromFile(getStorageFile());
        historyPatch.clear(); // It does not make sense to preserve history on load.
        return JsonUtil.fromJsonString(this.currJson, TodoListDB.class);
    }

    @Override
    public TodoListDB undo() throws CannotUndoException, IOException {
        // Get undo
        LinkedList<Patch> undoPatch;
        try {
            undoPatch = historyPatch.removeLast();
        } catch (NoSuchElementException e) {
            throw new CannotUndoException(e);
        }
        
        String newJson = (String)dmp.patchApply(undoPatch, this.currJson)[0];
        
        // Create redo
        LinkedList<Patch> redoPatch = dmp.patchMake(newJson, this.currJson);
        futurePatch.addLast(redoPatch);
        
        // Apply undo
        this.currJson = newJson;
        FileUtil.writeToFile(getStorageFile(), this.currJson);
        return JsonUtil.fromJsonString(this.currJson, TodoListDB.class);
    }
    
    @Override
    public int undoSize() {
        return historyPatch.size();
    }

    @Override
    public TodoListDB redo() throws CannotRedoException, IOException {
        // Get redo
        LinkedList<Patch> redoPatch;
        try {
            redoPatch = futurePatch.removeLast();
        } catch (NoSuchElementException e) {
            throw new CannotRedoException(e);
        }
        
        String newJson = (String)dmp.patchApply(redoPatch, this.currJson)[0];
        
        // Create undo
        LinkedList<Patch> undoPatch = dmp.patchMake(newJson, this.currJson);
        historyPatch.addLast(undoPatch);
        
        // Apply redo
        this.currJson = newJson;
        FileUtil.writeToFile(getStorageFile(), this.currJson);
        return JsonUtil.fromJsonString(this.currJson, TodoListDB.class);
    }
    
    @Override
    public int redoSize() {
        return futurePatch.size();
    }

}
```
###### \java\seedu\todo\storage\Storage.java
``` java
/**
 * Storage interface for persisting and loading from disk.
 */
public interface Storage {

    /**
     * Persists a TodoListDB object to disk.
     * @param db    TodoListDB object
     * @throws IOException  If there is an error writing to disk.
     */
    public void save(TodoListDB db) throws IOException;

    /**
     * Loads a TodoListDB object from disk
     * @return  TodoListDB object
     * @throws IOException  If there is an error reading from disk.
     */
    public TodoListDB load() throws IOException;

    public void move(String newPath) throws IOException;

    /**
     * Rolls back the DB by one commit, persists the DB, and returns a
     * TodoListDB object.
     * 
     * Undo information is on a per-session basis, and should not be persisted
     * to disk.
     * 
     * @return TodoListDB object
     * @throws CannotUndoException
     *             If there is nothing to undo.
     * @throws IOException
     *             If there is an error writing to disk.
     */
    public TodoListDB undo() throws CannotUndoException, IOException;

    /**
     * Rolls forward the DB by one undo commit, persists the DB, and returns a
     * TodoListDB object.
     * 
     * @return TodoListDB object
     * @throws CannotRedoException
     *             If there is nothing to redo.
     * @throws IOException
     *             If there is an error writing to disk.
     */
    public TodoListDB redo() throws CannotRedoException, IOException;
    
    /**
     * Returns the maximum possible number of undos.
     * @return undoSize
     */
    public int undoSize();
    
    /**
     * Returns the maximum possible number of redos.
     * @return
     */
    public int redoSize();

}
```
###### \java\seedu\todo\ui\components\AliasItem.java
``` java
public class AliasItem extends MultiComponent {
    
    private static final String FXML_PATH = "components/AliasItem.fxml";
    
    // Props
    public AliasDefinition aliasDefinition;
    
    // FXML
    @FXML
    private Text aliasKey;
    @FXML
    private Text aliasValue;

    @Override
    public String getFxmlPath() {
        return FXML_PATH;
    }
    
    @Override
    public void componentDidMount() {
        if (aliasDefinition != null) {
            aliasKey.setText(aliasDefinition.getAliasKey());
            aliasValue.setText(aliasDefinition.getAliasValue());
        }
    }

}
```
###### \java\seedu\todo\ui\views\AliasView.java
``` java
public class AliasView extends View {
    
    private static final String FXML_PATH = "views/AliasView.fxml";

    private static final String ICON_PATH = "/images/icon-settings.png";
    private static final String TEXT_INSTRUCTIONS = "Aliases make your life easier by allowing you to customize shortcuts!\n"
            + "To set an alias, use the following command:\n    alias <aliasKey> <aliasValue>";

    // FXML
    @FXML
    private Text aliasInstructionsText;
    @FXML
    private ImageView aliasImageView;
    @FXML
    private Pane aliasesPlaceholder;

    @Override
    public String getFxmlPath() {
        return FXML_PATH;
    }

    @Override
    public void componentDidMount() {
        // Makes the Component full width wrt parent container.
        FxViewUtil.makeFullWidth(this.mainNode);
        
        // Set instructions
        aliasInstructionsText.setText(TEXT_INSTRUCTIONS);

        // Load image
        aliasImageView.setImage(new Image(ICON_PATH));
        
        // Get definitions
        Map<String, String> aliasMap = ConfigCenter.getInstance().getConfig().getAliases();
        List<Map.Entry<String, String>> aliasDefinitions =
                new ArrayList<Map.Entry<String, String>>(aliasMap.entrySet());
        
        Comparator<Map.Entry<String, String>> aliasComparator = new Comparator<Map.Entry<String, String>>() {
            @Override
            public int compare(Entry<String, String> o1, Entry<String, String> o2) {
                return o1.getKey().compareTo(o2.getKey());
            }
        };
        Collections.sort(aliasDefinitions, aliasComparator);

        // Clear items
        AliasItem.reset(aliasesPlaceholder);

        // Load items
        loadAliases(aliasDefinitions);
    }

    /**
     * Load aliases into view.
     * 
     * @param aliasDefinitions  List of aliasDefinitions
     */
    private void loadAliases(List<Map.Entry<String, String>> aliasDefinitions) {
        for (Map.Entry<String, String> aliasPair : aliasDefinitions) {
            AliasItem item = load(primaryStage, aliasesPlaceholder, AliasItem.class);
            item.aliasDefinition = new AliasDefinition(aliasPair.getKey(), aliasPair.getValue());
            item.render();
        }
    }
    
}
```
###### \resources\ui\components\AliasItem.fxml
``` fxml
<VBox fx:id="aliasItem" styleClass="tasklist-dateitem" maxHeight="Infinity" maxWidth="Infinity" minHeight="-Infinity" minWidth="-Infinity" 
  xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" 
  fx:controller="seedu.todo.ui.components.AliasItem">
  <children>

    <HBox alignment="CENTER_LEFT">
      <children>
        <Text fx:id="aliasKey" wrappingWidth="100.0" VBox.vgrow="ALWAYS" />
        <Text fx:id="aliasValue" VBox.vgrow="ALWAYS" />
      </children>
    </HBox>
    
  </children>
  <padding>
    <Insets bottom="10.0" />
  </padding>
</VBox>
```
###### \resources\ui\views\AliasView.fxml
``` fxml
<VBox maxHeight="Infinity" maxWidth="Infinity" minHeight="100" minWidth="100" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.todo.ui.views.AliasView">
  <children>
    <HBox alignment="CENTER_LEFT">
      <children>
        <ImageView fitHeight="32.0" fitWidth="32.0" fx:id="aliasImageView" pickOnBounds="true" preserveRatio="true">
          <HBox.margin>
            <Insets right="10.0" />
          </HBox.margin>
        </ImageView>
        <Text styleClass="font-300, view-title-text" text="Command Aliases" />
      </children>
      <VBox.margin>
        <Insets bottom="20.0" />
      </VBox.margin>
    </HBox>
    
    <Text fx:id="aliasInstructionsText">
      <VBox.margin>
        <Insets bottom="20.0" />
      </VBox.margin>
    </Text>

    <HBox>
      <children>
    	<Text styleClass="font-500" wrappingWidth="100.0" VBox.vgrow="ALWAYS" text="Alias" />
	    <Text styleClass="font-500" VBox.vgrow="ALWAYS" text="Maps To..." />
      </children>
      <VBox.margin>
        <Insets bottom="10.0" />
      </VBox.margin>
    </HBox>
    
    <ScrollPane fitToHeight="true" fitToWidth="true" VBox.vgrow="ALWAYS">
      <content>
        <VBox styleClass="alias-pane" fx:id="aliasesPlaceholder" VBox.vgrow="ALWAYS">
          <padding>
            <Insets bottom="20.0" />
          </padding>
        </VBox>
      </content>
    </ScrollPane>
  </children>

  <padding>
    <Insets top="20.0" left="20.0" bottom="20.0" right="20.0" />
  </padding>
</VBox>
```
