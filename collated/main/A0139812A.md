# A0139812A
###### \java\seedu\todo\commons\core\CommandDefinition.java
``` java
/**
 * A CommandDefinition encapsulates the definition of a
 * command that is handled by a Controller.
 */
public class CommandDefinition {
    private String commandName;
    private String commandDescription;
    private String commandSyntax;
    private String commandKeyword;
    
    public CommandDefinition(String name, String desc, String syntax, String keyword) {
        commandName = name;
        commandDescription = desc;
        commandSyntax = syntax;
        setCommandKeyword(keyword);
    }
    
    public String getCommandName() {
        return commandName;
    }
    
    public void setCommandName(String commandName) {
        this.commandName = commandName;
    }
    
    public String getCommandDescription() {
        return commandDescription;
    }
    
    public void setCommandDescription(String commandDescription) {
        this.commandDescription = commandDescription;
    }
    
    public String getCommandSyntax() {
        return commandSyntax;
    }
    
    public void setCommandSyntax(String commandSyntax) {
        this.commandSyntax = commandSyntax;
    }

    public String getCommandKeyword() {
        return commandKeyword;
    }

    public void setCommandKeyword(String commandKeyword) {
        this.commandKeyword = commandKeyword;
    }

}
```
###### \java\seedu\todo\commons\core\Config.java
``` java
/**
 * Container class to contain config values used by the app.
 */
public class Config {

    public static final String DEFAULT_CONFIG_FILE = "config.json";

    // Config values customizable through config file
    private String appTitle = "GetShitDone";
    private Level logLevel = Level.INFO;
    private String databaseFilePath = "database.json";
    private Map<String, String> aliases = new HashMap<String, String>();

    public Config() {
    }

    public String getAppTitle() {
        return appTitle;
    }

    public void setAppTitle(String appTitle) {
        this.appTitle = appTitle;
    }

    public Level getLogLevel() {
        return logLevel;
    }

    public void setLogLevel(Level logLevel) {
        this.logLevel = logLevel;
    }

    public String getDatabaseFilePath() {
        return databaseFilePath;
    }

    public void setDatabaseFilePath(String databaseFilePath) {
        this.databaseFilePath = databaseFilePath;
    }
    
    public Map<String, String> getAliases() {
        return aliases;
    }


    @Override
    public boolean equals(Object other) {
        if (other == this){
            return true;
        }
        if (!(other instanceof Config)){ //this handles null as well.
            return false;
        }

        Config o = (Config)other;

        return Objects.equals(appTitle, o.appTitle)
                && Objects.equals(logLevel, o.logLevel)
                && Objects.equals(databaseFilePath, o.databaseFilePath);
    }

    @Override
    public int hashCode() {
        return Objects.hash(appTitle, logLevel, databaseFilePath);
    }

    @Override
    public String toString(){
        StringBuilder sb = new StringBuilder();
        sb.append("App title : " + appTitle);
        sb.append("\nCurrent log level : " + logLevel);
        sb.append("\nLocal data file location : " + databaseFilePath);
        return sb.toString();
    }
    
    public List<ConfigDefinition> getDefinitions() {
        ConfigDefinition configAppTitle = new ConfigDefinition("appTitle", "App Title", appTitle);
        ConfigDefinition configDatabaseFilePath = new ConfigDefinition("databaseFilePath", "Database File Path", databaseFilePath);
                
        return Arrays.asList(configAppTitle, configDatabaseFilePath);
    }
    
    public List<String> getDefinitionsNames() {
        List<ConfigDefinition> definitions = getDefinitions();
        List<String> names = new ArrayList<>();
        
        for (ConfigDefinition definition : definitions) {
            names.add(definition.getConfigName());
        }
        
        return names;
    }

}
```
###### \java\seedu\todo\commons\core\ConfigCenter.java
``` java
/**
 * Singleton to store the current Config used by the app.
 * This is especially necessary in a testing environment, 
 * and needs to be decoupled with the MainApp instance,
 * but rather instantiated independently.
 */
public class ConfigCenter {
    private static final Logger logger = LogsCenter.getLogger(MainApp.class);

    private static ConfigCenter instance;
    
    private Config config;
    private String configFilePath;

    public static ConfigCenter getInstance() {
        if (instance == null) {
            instance = new ConfigCenter();
        }
        
        return instance;
    }
    
    public void setConfigFilePath(String path) {
        configFilePath = path;
    }
    
    public Config getConfig() {
        if (config == null) {
            Optional<Config> configOptional;
            
            try {
                configOptional = ConfigUtil.readConfig(configFilePath);
                config = configOptional.orElse(new Config());
            } catch (DataConversionException e) {
                logger.warning("Config file at " + configFilePath + " is not in the correct format. " +
                        "Using default config properties");
            }
        }
        
        return config;
    }
    
    public void saveConfig(Config config) throws IOException {
        ConfigUtil.saveConfig(config, configFilePath);
        this.config = config;
    }
}
```
###### \java\seedu\todo\commons\core\ConfigDefinition.java
``` java
/**
 * Container class to store and retrieve config value properties.
 * Each ConfigDefinition refers to a single config value (e.g. {@code appTitle})
 * and stores the name, description and the current value.
 */
public class ConfigDefinition {
    private String configName;
    private String configDescription;
    private String configValue;
    
    public ConfigDefinition(String configName, String configDescription, String configValue) {
        this.configName = configName;
        this.configDescription = configDescription;
        this.configValue = configValue;
    }
    
    public String getConfigName() {
        return configName;
    }
    
    public String getConfigDescription() {
        return configDescription;
    }
    
    public String getConfigValue() {
        return configValue;
    }
}
```
###### \java\seedu\todo\commons\util\DateUtil.java
``` java
/**
 * A utility class for Dates and LocalDateTimes
 */
public class DateUtil {
    
    public static final LocalDateTime NO_DATETIME_VALUE = LocalDateTime.MIN;
    public static final LocalDate NO_DATE_VALUE = NO_DATETIME_VALUE.toLocalDate();

    private static final String FROM_NOW = "later";
    private static final String TILL_NOW = "ago";
    private static final String TODAY = "Today";
    private static final String TOMORROW = "Tomorrow";
    private static final String DAY = "day";
    private static final String DAYS = "days";
    
    /**
     * Converts a LocalDateTime object to a legacy java.util.Date object.
     * 
     * @param dateTime   LocalDateTime object.
     * @return           Date object.
     */
    public static Date toDate(LocalDateTime dateTime) {
        return Date.from(dateTime.atZone(ZoneId.systemDefault()).toInstant());
    }

    /**
     * Performs a "floor" operation on a LocalDateTime, and returns a new LocalDateTime
     * with time set to 00:00.
     * 
     * @param dateTime   LocalDateTime for operation to be performed on.
     * @return           "Floored" LocalDateTime.
     */
    public static LocalDateTime floorDate(LocalDateTime dateTime) {
        if (dateTime == null) {
            return null;
        }
        
        return dateTime.toLocalDate().atTime(0, 0);
    }

    /**
     * Formats a LocalDateTime to a relative date. 
     * Prefers DayOfWeek format, for dates up to 6 days from today.
     * Otherwise, returns a relative time (e.g. 13 days from now).
     * 
     * @param dateTime   LocalDateTime to format.
     * @return           Formatted relative day.
     */
    public static String formatDay(LocalDateTime dateTime) {
        if (dateTime == null) {
            return null;
        }
        
        LocalDate date = dateTime.toLocalDate();
        long daysDifference = LocalDate.now().until(date, ChronoUnit.DAYS);

        // Consider today's date.
        if (date.isEqual(LocalDate.now())) {
            return TODAY;
        }
        
        if (daysDifference == 1) {
            return TOMORROW;
        }

        // Consider dates up to 6 days from today.
        if (daysDifference > 1 && daysDifference <= 6) {
            return date.getDayOfWeek().getDisplayName(TextStyle.FULL, Locale.US);
        }

        // Otherwise, dates should be a relative days ago/from now format.
        return String.format("%d %s %s", Math.abs(daysDifference), 
                StringUtil.pluralizer((int) Math.abs(daysDifference), DAY, DAYS), 
                daysDifference > 0 ? FROM_NOW : TILL_NOW);
    }
    
    /**
     * Formats a LocalDateTime to a formatted date, following the dd MMM yyyy format.
     * 
     * @param dateTime   LocalDateTime to format.
     * @return           Formatted date in dd MMM yyyy format.
     */
    public static String formatDate(LocalDateTime dateTime) {
        return dateTime.format(DateTimeFormatter.ofPattern("dd MMM yyyy"));
    }

    /**
     * Formats a LocalDateTime to a ISO formatted date, following the ISO yyyy-MM-dd format.
     * 
     * @param dateTime   LocalDateTime to format.
     * @return           Formatted date in ISO format.
     */
    public static String formatIsoDate(LocalDateTime dateTime) {
        return dateTime.format(DateTimeFormatter.ofPattern("yyyy-MM-dd"));
    }
    
    /**
     * Formats a LocalDateTime to a short date. Excludes the day of week only if
     * the date is within 2-6 days from now.
     * 
     * @param dateTime   LocalDateTime to format.
     * @return           Formatted shorten day.
     */
    public static String formatShortDate(LocalDateTime dateTime) {
        if (dateTime == null) {
            return null;
        }
        
        LocalDate date = dateTime.toLocalDate();
        long daysDifference = LocalDate.now().until(date, ChronoUnit.DAYS);
        String dateFormat;
        
        // Don't show dayOfWeek for days d, such that d = {n+2,...,n+6}, where n = date now
        if (daysDifference >= 2 && daysDifference <= 6) {
            dateFormat = "dd MMM";
        } else {
            dateFormat = "E dd MMM";
        }
        
        return date.format(DateTimeFormatter.ofPattern(dateFormat));
    }
    
    /**
     * Parses a short date (as defined in {@link formatShortDate}) back to a LocalDateTime.
     * We ignore the day of week portion for simplicity, since the shortDate can optionally omit it.
     * 
     * @param shortDateToParse   Date string to format.
     * @return                  Parsed LocalDateTime.
     */
    public static LocalDate parseShortDate(String shortDateToParse) {
        String[] dateParts = shortDateToParse.split(" ");
        String dateString;
        
        // Get the current year to add to the parsing since we cannot parse without a year...
        int currentYear = Calendar.getInstance().get(Calendar.YEAR);
        
        if (dateParts.length < 2 || dateParts.length > 3) {
            return null;
        }
        
        if (dateParts.length == 3) {
            dateString = String.format("%s %s %d", dateParts[1], dateParts[2], currentYear);
        } else {
            dateString = String.format("%s %s %d", dateParts[0], dateParts[1], currentYear);
        }
        
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd MMM yyyy");
        return LocalDate.parse(dateString, formatter);
    }
    
    /**
     * Formats a LocalDateTime to a 24-hour time.
     * 
     * @param dateTime   LocalDateTime to format.
     * @return           24-hour time formatted string.
     */
    public static String formatTime(LocalDateTime dateTime) {
        if (dateTime == null) {
            return null;
        }
        
        return dateTime.toLocalTime().format(DateTimeFormatter.ofPattern("HH:mm"));
    }
    
    /**
     * Parses a ISO-format time string ({@code HH:mm}) into a LocalTime.
     */
    public static LocalTime parseTime(String timeString) {
        return LocalTime.parse(timeString, DateTimeFormatter.ofPattern("HH:mm"));
    }
    
    /**
     * Formats a LocalDateTime into short date + time format.
     * @param dateTime   LocalDateTime to format.
     * @return           Short date + time formatted string.
     */
    public static String formatDateTime(LocalDateTime dateTime) {
        return String.format("%s %s", formatShortDate(dateTime), formatTime(dateTime));
    }
    
    /**
     * Formats a start date and end date to a date range, which will display only as much info as necessary.
     * @param dateFrom   LocalDateTime from.
     * @param dateTo     LocalDateTime to.
     * @return           Formatted string.
     */
    public static String formatDateFromTo(LocalDateTime dateFrom, LocalDateTime dateTo) {
        if (dateFrom == null && dateTo == null) {
            return "";
        } else if (dateTo == null) {
            // No endDate
            return formatTime(dateFrom);
        } else if (dateFrom.isAfter(dateTo)) {
            // Unhandled error, just ignore endDate and assume it has no endDate
            return formatTime(dateFrom);
        } else if (dateFrom.toLocalDate().equals(dateTo.toLocalDate())) {
            return String.format("%s - %s", formatTime(dateFrom), formatTime(dateTo));
        } else {
            return String.format("%s - %s", formatDateTime(dateFrom), formatDateTime(dateTo));
        }
    }
    
    /**
     * Parses a dateTime string with the standard ISO format {@code yyyy-MM-dd HH:mm:ss}.
     * 
     * @param dateTimeString
     * @return
     */
    public static LocalDateTime parseDateTime(String dateTimeString) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        return LocalDateTime.parse(dateTimeString, formatter);
    }

}
```
###### \java\seedu\todo\commons\util\FxViewUtil.java
``` java
/**
 * Contains utility methods for JavaFX views
 */
public class FxViewUtil {

    public static void applyAnchorBoundaryParameters(Node node, double left, double right, double top, double bottom) {
        AnchorPane.setBottomAnchor(node, bottom);
        AnchorPane.setLeftAnchor(node, left);
        AnchorPane.setRightAnchor(node, right);
        AnchorPane.setTopAnchor(node, top);
    }
    
    public static void makeFullWidth(Node node) {
    	applyAnchorBoundaryParameters(node, 0.0, 0.0, 0.0, 0.0);
    }
}
```
###### \java\seedu\todo\commons\util\ListUtil.java
``` java
public class ListUtil {

    /**
     * Checks if two lists are equal, without regard for order.
     */
    public static <T> boolean unorderedListEquals(List<T> list1, List<T> list2) {
        final Set<T> set1 = new HashSet<>(list1);
        final Set<T> set2 = new HashSet<>(list2);

        return set1.equals(set2);
    }
    
}
```
###### \java\seedu\todo\controllers\CompleteTaskController.java
``` java
/**
 * Controller to mark a task as completed.
 */
public class CompleteTaskController extends Controller {
    
    private static final String NAME = "Complete Task";
    private static final String DESCRIPTION = "Marks a task as completed, by listed index";
    private static final String COMMAND_SYNTAX = "complete <index>";
    private static final String COMMAND_KEYWORD = "complete";
    
    public static final String MESSAGE_SUCCESS = "Task marked as complete!";
    public static final String MESSAGE_MISSING_INDEX = "Please specify the index of the item to delete.";
    public static final String MESSAGE_INDEX_NOT_NUMBER = "Index has to be a number!";
    public static final String MESSAGE_INVALID_ITEM = "Could not mark task as complete: Invalid index provided!";
    public static final String MESSAGE_CANNOT_COMPLETE_EVENT = "An event cannot be marked as complete!";
    public static final String MESSAGE_ALREADY_COMPLETED = "Could not mark task as complete: Task is already complete!";
    public static final String MESSAGE_COULD_NOT_SAVE = "Could not mark task as complete: An error occured while saving the database file.";
    
    private static CommandDefinition commandDefinition =
            new CommandDefinition(NAME, DESCRIPTION, COMMAND_SYNTAX, COMMAND_KEYWORD); 

    @Override
    public CommandDefinition getCommandDefinition() {
        return commandDefinition;
    }

    @Override
    public void process(String args) {
        // Get index.
        String param = args.replaceFirst(COMMAND_KEYWORD, "").trim();
        
        if (param.length() <= 0) {
            Renderer.renderDisambiguation(COMMAND_SYNTAX, MESSAGE_MISSING_INDEX);
            return;
        }
        
        assert param.length() > 0;
        
        // Get index.
        int index = 0;
        try {
            index = Integer.decode(param);
        } catch (NumberFormatException e) {
            Renderer.renderDisambiguation(COMMAND_SYNTAX, MESSAGE_INDEX_NOT_NUMBER);
            return;
        }
        
        // Get record
        EphemeralDB edb = EphemeralDB.getInstance();
        CalendarItem calendarItem = edb.getCalendarItemsByDisplayedId(index);
        TodoListDB db = TodoListDB.getInstance();
        
        if (calendarItem == null) {
            Renderer.renderIndex(db, MESSAGE_INVALID_ITEM);
            return;
        }
        
        if (!(calendarItem instanceof Task)) {
            Renderer.renderIndex(db, MESSAGE_CANNOT_COMPLETE_EVENT);
            return;
        }
        
        Task task = (Task) calendarItem;
        
        if (task.isCompleted()) {
            Renderer.renderIndex(db, MESSAGE_ALREADY_COMPLETED);
            return;
        }
        
        // Set task as completed
        task.setCompleted();
        boolean hadSaved = db.save();
        
        if (!hadSaved) {
            task.setIncomplete();
            Renderer.renderIndex(db, MESSAGE_COULD_NOT_SAVE);
            return;
        }
        
        // Show success
        Renderer.renderIndex(db, MESSAGE_SUCCESS);
    }

}
```
###### \java\seedu\todo\controllers\concerns\Disambiguator.java
``` java
/**
 * Concern to generate disambiguation strings that will be returned from a Controller
 * back to the UI, for the user to correct an invalid/ambiguous command.
 */
public class Disambiguator {
    
    private static final String TOKEN_NAME = "name";
    public static final String PLACEHOLDER_NAME = "<name>";
    private static final String TOKEN_TASKSTATUS = "taskStatus";
    public static final String PLACEHOLDER_TASKSTATUS = "<task status>";
    private static final String TOKEN_EVENTSTATUS = "eventStatus";
    public static final String PLACEHOLDER_EVENTSTATUS = "<event status>";
    private static final String TOKEN_TAG = "tag";
    public static final String PLACEHOLDER_TAG = "<tag>";
    private static final String TOKEN_STARTTIME = "startTime";
    public static final String PLACEHOLDER_STARTTIME = "<start>";
    private static final int INDEX_STARTTIME = 0;
    private static final String TOKEN_ENDTIME = "endTime";
    public static final String PLACEHOLDER_ENDTIME = "<end>";
    private static final int INDEX_ENDTIME = 1;
    
    /**
     * Extracts the first token from each type of token. 
     * If the token doesn't exist, it will be replaced with a default placeholder.
     * This is for the purpose of rendering disambiguation strings.
     */
    public static Map<String, String> extractParsedTokens(Map<String, String[]> parsedResult) {
        Map<String, String> tokens = new HashMap<>();
        
        // Extract tokens
        tokens.put(TOKEN_NAME, extractKeyOrValue(parsedResult, true, TOKEN_NAME, PLACEHOLDER_NAME));
        tokens.put(TOKEN_TASKSTATUS, extractKeyOrValue(parsedResult, false, TOKEN_TASKSTATUS, PLACEHOLDER_TASKSTATUS));
        tokens.put(TOKEN_EVENTSTATUS, extractKeyOrValue(parsedResult, false, TOKEN_EVENTSTATUS, PLACEHOLDER_EVENTSTATUS));
        tokens.put(TOKEN_TAG, extractKeyOrValue(parsedResult, true, TOKEN_TAG, PLACEHOLDER_TAG));
        
        // Time start/end
        String[] datePair = DateParser.extractDatePair(parsedResult);
        tokens.put(TOKEN_STARTTIME, StringUtil.replaceEmpty(datePair[INDEX_STARTTIME], PLACEHOLDER_STARTTIME));
        tokens.put(TOKEN_ENDTIME, StringUtil.replaceEmpty(datePair[INDEX_ENDTIME], PLACEHOLDER_ENDTIME));
        
        return tokens;
    }
    
    /**
     * Extracts the key or value of the token value array, and returns it.
     * Accepts a placeholder string in the event that the key or value doesn't exist.
     */
    private static String extractKeyOrValue(Map<String, String[]> parsedResult, boolean extractValue, String key, String placeholder) {
        int n = extractValue ? 1 : 0;
        
        // Extracts the key or value depending on extractKey.
        String extracted = null;
        if (parsedResult.get(key) != null && parsedResult.get(key).length > n) {
            extracted = parsedResult.get(key)[n];
        }
        
        // Replaces with placeholder if empty.
        extracted = StringUtil.replaceEmpty(extracted, placeholder);
        
        return extracted;
    }
    
    /**
     * Extracts any unknown token strings from the parsed result.
     */
    public static String getUnknownTokenString(Map<String, String[]> parsedResult) {
        String[] defaultToken = parsedResult.get("default");
        
        if (defaultToken != null && defaultToken[1] != null && defaultToken[1].length() > 0) {
            return defaultToken[1];
        } else {
            return null;
        }
    }
}
```
###### \java\seedu\todo\controllers\ConfigController.java
``` java
/**
 * Controller to configure app settings.
 * Has side effects, since it has to perform
 * updates on the UI or file sources on update.
 */
public class ConfigController extends Controller {

    private static final String NAME = "Configure";
    private static final String DESCRIPTION = "Shows current configuration settings or updates them.";
    private static final String COMMAND_SYNTAX = "config [<setting> <value>]";
    private static final String COMMAND_KEYWORD = "config";

    private static final String MESSAGE_SHOWING = "Showing all settings.";
    private static final String MESSAGE_SUCCESS = "Successfully updated %s.";
    public static final String MESSAGE_FAILURE = "Could not update settings: %s";
    private static final String MESSAGE_INVALID_INPUT = "Invalid config setting provided!";
    public static final String MESSAGE_WRONG_EXTENSION = "Could not change storage path: File must end with %s";
    public static final String TEMPLATE_SET_CONFIG = "config <setting> <value>";
    
    private static final String STRING_SPACE = " ";
    private static final int ARGS_LENGTH = 2;
    public static final String DB_FILE_EXTENSION = ".json";

    private static CommandDefinition commandDefinition =
            new CommandDefinition(NAME, DESCRIPTION, COMMAND_SYNTAX, COMMAND_KEYWORD); 

    @Override
    public CommandDefinition getCommandDefinition() {
        return commandDefinition;
    }

    @Override
    public void process(String input) {
        String params = input.replaceFirst("config", "").trim();

        // Check for basic command.
        if (params.length() <= 0) {
            Renderer.renderConfig(MESSAGE_SHOWING);
            return;
        }
        
        // Check args length
        String[] args = params.split(STRING_SPACE, ARGS_LENGTH);
        if (args.length != ARGS_LENGTH) {
            Renderer.renderDisambiguation(TEMPLATE_SET_CONFIG, MESSAGE_INVALID_INPUT);
            return;
        }
        
        String configName = args[0];
        String configValue = args[1];
        Config config = ConfigCenter.getInstance().getConfig();

        // Check if configName is a valid name.
        if (!config.getDefinitionsNames().contains(configName)) {
            Renderer.renderDisambiguation(TEMPLATE_SET_CONFIG, MESSAGE_INVALID_INPUT);
            return;
        }

        try {
            // Update config value
            config = updateConfigByName(config, configName, configValue);
            
            // Save config to file
            ConfigCenter.getInstance().saveConfig(config);
        } catch (CannotConfigureException | IOException e) {
            Renderer.renderConfig(String.format(MESSAGE_FAILURE, e.getMessage()));
            return;
        }

        // Update console for success
        Renderer.renderConfig(String.format(MESSAGE_SUCCESS, configName));
    }

    /**
     * Updates a config value and performs the necessary actions for the configuration.
     * Throws a {@code CannotConfigureException} if an error was encountered while performing configuration actions.
     * 
     * @param config         Config object which will be updated.
     * @param configName     Config setting name to update.
     * @param configValue    New value to set for the config setting.
     * @return               Config object after setting values.
     * @throws CannotConfigureException if an error was encountered during configuration.
     */
    private Config updateConfigByName(Config config, String configName, String configValue) throws CannotConfigureException {
        switch (configName) {
        case "appTitle" :
            // Updates MainWindow title
            UiManager.getInstance().getMainWindow().setTitle(configValue);

            // Update config
            config.setAppTitle(configValue);

            break;

        case "databaseFilePath" :
            // Move the DB file to the new location
            moveDatabaseFile(configValue);

            // Update config
            config.setDatabaseFilePath(configValue);

            break;

        default :
            break;
        }

        return config;
    }
    
    /**
     * Moves the database file to the new location.
     * Throws an exception if the new path does not exist, or if it has the wrong extension.
     */
    private void moveDatabaseFile(String newPath) throws CannotConfigureException {
        // Make sure the new path has a .json extension
        if (!newPath.endsWith(DB_FILE_EXTENSION)) {
            throw new CannotConfigureException(String.format(MESSAGE_WRONG_EXTENSION, DB_FILE_EXTENSION));
        }

        try {
            TodoListDB.getInstance().move(newPath);
        } catch (IOException e) {
            throw new CannotConfigureException(e.getMessage());
        }
    }

}
```
###### \java\seedu\todo\controllers\HelpController.java
``` java
/**
 * Controller to show commands help.
 */
public class HelpController extends Controller {

    private static final String NAME = "Help";
    private static final String DESCRIPTION = "Shows documentation for all valid commands.";
    private static final String COMMAND_SYNTAX = "help";
    private static final String COMMAND_KEYWORD = "help";
    
    private static final String MESSAGE_HELP_SUCCESS = "Showing all commands.";
    
    private static CommandDefinition commandDefinition =
            new CommandDefinition(NAME, DESCRIPTION, COMMAND_SYNTAX, COMMAND_KEYWORD); 

    @Override
    public CommandDefinition getCommandDefinition() {
        return commandDefinition;
    }

    @Override
    public void process(String input) {
        HelpView view = UiManager.loadView(HelpView.class);
        view.commandDefinitions = Arrays.asList(getAllCommandDefinitions());
        UiManager.renderView(view);
        
        UiManager.updateConsoleMessage(MESSAGE_HELP_SUCCESS);
    }
    
    public CommandDefinition[] getAllCommandDefinitions() {
        return new CommandDefinition[] { new HelpController().getCommandDefinition(),
                                         new AddController().getCommandDefinition(),
                                         new ListController().getCommandDefinition(),
                                         new UpdateController().getCommandDefinition(),
                                         new CompleteTaskController().getCommandDefinition(),
                                         new UncompleteTaskController().getCommandDefinition(),
                                         new DestroyController().getCommandDefinition(),
                                         new ConfigController().getCommandDefinition(),
                                         new DestroyController().getCommandDefinition(),
                                         new ClearController().getCommandDefinition(),
                                         new FindController().getCommandDefinition(),
                                         new TagController().getCommandDefinition(),
                                         new UntagController().getCommandDefinition(),
                                         new ExitController().getCommandDefinition() };
    }
}
```
###### \java\seedu\todo\controllers\ListController.java
``` java
/**
 * Controller to list CalendarItems.
 */
public class ListController extends Controller {
    
    private static final String NAME = "List";
    private static final String DESCRIPTION = "Lists all tasks and events.";
    private static final String COMMAND_SYNTAX = "list [task/event] [complete/incomplete] [on date] or [from date to date]";
    private static final String COMMAND_KEYWORD = "list";
    
    private static final String MESSAGE_LISTING_ALL = "Showing all tasks and events.\n\n"
                                                    + "You have a total of %d incomplete tasks, %d overdue tasks, "
                                                    + "and %d upcoming events.";
    private static final String MESSAGE_LISTING_FILTERED = "Showing %s %s and %s %s.\n\nYour query: %s";
    private static final String MESSAGE_UNKNOWN_TOKENS = "Could not parse your query as it contained unknown tokens: %s";
    private static final String MESSAGE_AMBIGUOUS_TYPE = "We could not tell if you wanted to clear events or tasks. \n"
            + "Note that only tasks can be \"complete\"/\"incomplete\", "
            + "while only events can be \"past\", \"over\" or \"future\".";
    private static final String MESSAGE_INVALID_DATE = "We could not parse the date in your query, please try again.";
    
    public static final String TEMPLATE_LIST = "list [from \"%s\"] [to \"%s\"] [tag \"%s\"]";
    public static final String TEMPLATE_LIST_TASKS = "list tasks [\"%s\"] [from \"%s\"] [to \"%s\"] [tag \"%s\"]";
    public static final String TEMPLATE_LIST_EVENTS = "list events [\"%s\"] [from \"%s\"] [to \"%s\"] [tag \"%s\"]";
    
    private static CommandDefinition commandDefinition =
            new CommandDefinition(NAME, DESCRIPTION, COMMAND_SYNTAX, COMMAND_KEYWORD); 

    @Override
    public CommandDefinition getCommandDefinition() {
        return commandDefinition;
    }
    
    @Override
    public void process(String input) throws ParseException {
        
        TodoListDB db = TodoListDB.getInstance();        
        
        // First, we check if it's a basic command, then don't bother filtering.
        if (input.toLowerCase().trim().equals(COMMAND_KEYWORD)) {
            String consoleMessage = String.format(MESSAGE_LISTING_ALL, db.countIncompleteTasks(), 
                    db.countOverdueTasks(), db.countFutureEvents());
            Renderer.renderIndex(db, consoleMessage);
            return;
        }
        
        List<Task> filteredTasks = new ArrayList<>();
        List<Event> filteredEvents = new ArrayList<>();
        
        // Parse the input with Tokenizer.
        Map<String, String[]> parsedResult = Tokenizer.tokenize(CalendarItemFilter.getFilterTokenDefinitions(), input);
        
        // Check if there are any unknown tokens.
        if (Disambiguator.getUnknownTokenString(parsedResult) != null) {
            String errorMessage = String.format(MESSAGE_UNKNOWN_TOKENS, Disambiguator.getUnknownTokenString(parsedResult));
            renderDisambiguation(parsedResult, true, true, errorMessage);
            return;
        }

        // Determine if command should return tasks/events/both.
        boolean[] tasksOrEventsBools;
        try {
            tasksOrEventsBools = CalendarItemFilter.parseIsTaskEvent(parsedResult);
        } catch (AmbiguousEventTypeException e) {
            renderDisambiguation(parsedResult, true, true, MESSAGE_AMBIGUOUS_TYPE);
            return;
        }
        
        boolean isTask = tasksOrEventsBools[0];
        boolean isEvent = tasksOrEventsBools[1];

        // Filter tasks and events.
        try {
            if (isTask) {
                filteredTasks = CalendarItemFilter.filterTasks(parsedResult);
            }
            if (isEvent) {
                filteredEvents = CalendarItemFilter.filterEvents(parsedResult);
            }
        } catch (InvalidNaturalDateException e) {
            renderDisambiguation(parsedResult, isTask, isEvent, MESSAGE_INVALID_DATE);
            return;
        }
        
        // Render the new view with filtered tasks.
        String consoleMessage = String.format(MESSAGE_LISTING_FILTERED, 
                filteredTasks.size(), StringUtil.pluralizer(filteredTasks.size(), "task", "tasks"),
                filteredEvents.size(), StringUtil.pluralizer(filteredEvents.size(), "event", "events"), input);
        Renderer.renderSelected(TodoListDB.getInstance(), consoleMessage, filteredTasks, filteredEvents);
    }
    
    /**
     * Disambiguate an ambiguous input by auto-populating a templated command on
     * a best-effort basis.
     * 
     * @param parsedResult
     * @param isTask
     * @param isEvent
     * @param errorMessage
     */
    private void renderDisambiguation(Map<String, String[]> parsedResult, boolean isTask, boolean isEvent, String errorMessage) {
        Map<String, String> extractedTokens = Disambiguator.extractParsedTokens(parsedResult);
        String consoleCommand;
        
        if ((isTask && isEvent) || (!isTask && !isEvent)) {
            consoleCommand = String.format(TEMPLATE_LIST, extractedTokens.get("startTime"), 
                    extractedTokens.get("endTime"), extractedTokens.get("tag"));
        } else if (isTask) {
            consoleCommand = String.format(TEMPLATE_LIST_TASKS, extractedTokens.get("taskStatus"), 
                    extractedTokens.get("startTime"), extractedTokens.get("endTime"), extractedTokens.get("tag"));
        } else {
            consoleCommand = String.format(TEMPLATE_LIST_EVENTS, extractedTokens.get("eventStatus"), 
                    extractedTokens.get("startTime"), extractedTokens.get("endTime"), extractedTokens.get("tag"));
        }
        
        Renderer.renderDisambiguation(consoleCommand, errorMessage);
    }
}
```
###### \java\seedu\todo\controllers\UncompleteTaskController.java
``` java
/**
 * Controller to mark a task as uncompleted.
 */
public class UncompleteTaskController extends Controller {
    
    private static final String NAME = "Uncomplete Task";
    private static final String DESCRIPTION = "Marks a task as incomplete, by listed index";
    private static final String COMMAND_SYNTAX = "uncomplete <index>";
    private static final String COMMAND_KEYWORD = "uncomplete";

    public static final String MESSAGE_SUCCESS = "Task marked as incomplete!";
    public static final String MESSAGE_MISSING_INDEX = "Please specify the index of the item to delete.";
    public static final String MESSAGE_INDEX_NOT_NUMBER = "Index has to be a number!";
    public static final String MESSAGE_INVALID_ITEM = "Could not mark task as incomplete: Invalid index provided!";
    public static final String MESSAGE_CANNOT_UNCOMPLETE_EVENT = "An event cannot be marked as incomplete!";
    public static final String MESSAGE_ALREADY_INCOMPLETE = "Could not mark task as incomplete: Task is not completed!";
    public static final String MESSAGE_COULD_NOT_SAVE = "Could not mark task as incomplete: An error occured while saving the database file.";
    
    
    private static CommandDefinition commandDefinition =
            new CommandDefinition(NAME, DESCRIPTION, COMMAND_SYNTAX, COMMAND_KEYWORD);

    @Override
    public CommandDefinition getCommandDefinition() {
        return commandDefinition;
    }

    @Override
    public void process(String args) {
        // Get index.
        String param = args.replaceFirst(COMMAND_KEYWORD, "").trim();
        
        if (param.length() <= 0) {
            Renderer.renderDisambiguation(COMMAND_SYNTAX, MESSAGE_MISSING_INDEX);
            return;
        }
        
        assert param.length() > 0;
        
        // Get index.
        int index = 0;
        try {
            index = Integer.decode(param);
        } catch (NumberFormatException e) {
            Renderer.renderDisambiguation(COMMAND_SYNTAX, MESSAGE_INDEX_NOT_NUMBER);
            return;
        }
        
        // Get record
        EphemeralDB edb = EphemeralDB.getInstance();
        CalendarItem calendarItem = edb.getCalendarItemsByDisplayedId(index);
        TodoListDB db = TodoListDB.getInstance();
        
        if (calendarItem == null) {
            Renderer.renderIndex(db, MESSAGE_INVALID_ITEM);
            return;
        }
        
        if (!(calendarItem instanceof Task)) {
            Renderer.renderIndex(db, MESSAGE_CANNOT_UNCOMPLETE_EVENT);
            return;
        }
        
        Task task = (Task) calendarItem;
        
        if (!task.isCompleted()) {
            Renderer.renderIndex(db, MESSAGE_ALREADY_INCOMPLETE);
            return;
        }
        
        // Set task as completed
        task.setIncomplete();
        boolean hadSaved = db.save();
        
        if (!hadSaved) {
            task.setCompleted();
            Renderer.renderIndex(db, MESSAGE_COULD_NOT_SAVE);
            return;
        }
        
        // Show success message
        Renderer.renderIndex(db, MESSAGE_SUCCESS);
    }

}
```
###### \java\seedu\todo\MainApp.java
``` java
/**
 * The main entry point to the application.
 */
public class MainApp extends Application {
    private static final Logger logger = LogsCenter.getLogger(MainApp.class);

    public static final Version VERSION = new Version(1, 0, 0, true);
    
    private static final String MESSAGE_WELCOME = "Welcome! What would like to get done today?";

    private static final ConfigCenter configCenter = ConfigCenter.getInstance();
    private String configFilePath;
    protected Config config;
    
    protected UiManager ui;

    public MainApp() {}

    @Override
    public void init() throws Exception {
        super.init();
        
        // Read app param
        configFilePath = getApplicationParameter("config");

        // Initialize config from config file, or create a new one.
        initConfig();

        // Initialize logging
        initLogging(configCenter.getConfig());

        // Initialize events center
        initEventsCenter();

        // Initialize UI config
        UiManager.initialize(configCenter.getConfig());
        ui = UiManager.getInstance();

        // Load DB
        if (!TodoListDB.getInstance().load()) {
            TodoListDB.getInstance().save();
        }
    }

    @Override
    public void start(Stage primaryStage) {
        ui.start(primaryStage);

        IndexView view = UiManager.loadView(IndexView.class);
        view.tasks = TodoListDB.getInstance().getIncompleteTasksAndTaskFromTodayDate();
        view.events = TodoListDB.getInstance().getAllCurrentEvents();
        view.tags = TodoListDB.getInstance().getTagList();
        UiManager.renderView(view);
        
        // Show welcome message
        UiManager.updateConsoleMessage(MESSAGE_WELCOME);
    }

    @Override
    public void stop() {
        ui.stop();
        Platform.exit();
        System.exit(0);
    }

    /** ================== UTILS ====================== **/

    /**
     * Gets command-line parameter by name.
     * 
     * @param parameterName   Name of parameter
     * @return   Value of parameter
     */
    private String getApplicationParameter(String parameterName){
        Map<String, String> applicationParameters = getParameters().getNamed();
        return applicationParameters.get(parameterName);
    }

    /** ================== INITIALIZATION ====================== **/

    private void initLogging(Config config) {
        LogsCenter.init(config);
    }

    protected Config initConfig() {
        String configFilePathUsed;

        configFilePathUsed = Config.DEFAULT_CONFIG_FILE;

        if (configFilePath != null) {
            logger.info("Custom Config file specified " + configFilePath);
            configFilePathUsed = configFilePath;
        }
        
        configFilePath = configFilePathUsed;

        logger.info("Using config file : " + configFilePathUsed);

        return loadConfigFromFile(configFilePathUsed);
    }
    
    protected Config loadConfigFromFile(String configFilePathUsed) {
        configCenter.setConfigFilePath(configFilePathUsed);
        config = configCenter.getConfig();

        // Update config file in case it was missing to begin with or there are new/unused fields
        try {
            configCenter.saveConfig(config);
        } catch (IOException e) {
            logger.warning("Failed to save config file : " + StringUtil.getDetails(e));
        }

        return config;
    }

    private void initEventsCenter() {
        EventsCenter.getInstance().registerHandler(this);
    }

    /** ================== SUBSCRIPTIONS ====================== **/

    @Subscribe
    public void handleExitAppRequestEvent(ExitAppRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        this.stop();
    }

    /** ================== MAIN METHOD ====================== **/

    public static void main(String[] args) {
        launch(args);
    }
}
```
###### \java\seedu\todo\ui\components\Component.java
``` java
/**
 * The UI is predicated on the concept of a {@code Component}. 
 * A {@code Component} is a single sub-unit of the UI, and should preferably 
 * only be responsible for a single item or functionality in the UI. 
 * <br><br>
 * For example, a task item in the UI is a single {@code Component}, as it is 
 * responsible for purely displaying the task information. A task list 
 * is also a {@code Component}, as it contains multiple task items, and it is 
 * responsible just for rendering each task item.
 * <br><br>
 * A {@code Component} has the following properties:
 * 
 * <ul>
 * <li>Associated with FXML files</li>
 * <li>Loaded with load</li>
 * <li>Able to accept props</li>
 * <li>Rendered in placeholder panes</li>
 * <li>Can load sub-{@code Component}s</li>
 * </ul>
 * 
 * <em>Note: The concept of {@code Component}s and their associated behaviours came 
 * from React, a modern JavaScript library for the web.</em>
 */
public abstract class Component extends UiPart {

    private static final Logger logger = LogsCenter.getLogger(View.class);

    protected Pane placeHolderPane;
    protected Pane mainNode;
    
    /**
     * Loads a component into a placeholder.
     * 
     * <ul>
     * <li>Gets the FXML file specified in the {@link Component}, and loads the JavaFX node.</li>
     * <li>Loads a view controller that controls the node, and returns the view controller (ie. {@link Component}).</li>
     * </ul>
     * 
     * @param primaryStage      Stage to load the component on. Typically, a Component rendering other Components should pass in primaryStage.
     * @param placeholder       Placeholder {@code Pane} to render the component in.
     * @param componentClass    Class of the Component to render.
     * @return                  The Component, that controls the rendered JavaFX node.
     */
    public <T extends Component> T load(Stage primaryStage, Pane placeholder, Class<T> componentClass) {
        return UiPartLoader.loadUiPart(primaryStage, placeholder, componentClass);
    }

    /**
     * This method renders the View in the specified placeholder, if provided.
     * 
     * Note that all as specified in the FXML file, in the placeholder pane.
     * After loading the FXML file, the execution is then passed onto setNode, 
     * which will replace the placeholder contents accordingly.
     * 
     * @param primaryStage   The primary stage that contains the main application window.
     * @param placeholder    The placeholder pane where this View should reside.
     */    
    public void render() {
        // If the View is not loaded from the FXML file, we have no node to render.
        if (mainNode == null) {
            return;
        }

        assert mainNode != null;

        if (placeHolderPane != null) {
            // Replace placeholder children with node.
            placeHolderPane.getChildren().setAll(mainNode);
        } else {
            logger.warning(this.getClass().getName() + " has no placeholder.");
        }

        // Callback once view is rendered.
        componentDidMount();
    }

    public Node getNode() {
        return mainNode;
    }

    /**
     * Runs once the {@code render()} is called. Used to perform any of the following actions:
     * <li>Modify JavaFX components</li>
     * <li>Set the state of JavaFX components (such as value)</li>
     * <li>Load and render any children components</li>
     * 
     * Declaration is optional, and will default to not doing anything if it is not overridden in child components.
     */
    public void componentDidMount() {
        // Does nothing by default.
    }

    @Override
    public void setPlaceholder(Pane pane) {
        this.placeHolderPane = pane;
    }

    @Override
    public void setNode(Node node) {
        mainNode = (Pane) node;
    }

}
```
###### \java\seedu\todo\ui\components\ConfigItem.java
``` java
public class ConfigItem extends MultiComponent {

    private static final String FXML_PATH = "components/ConfigItem.fxml";
    
    // Props
    public ConfigDefinition configDefinition;
    
    // FXML
    @FXML
    private Text configDescription;
    @FXML
    private Text configName;
    @FXML
    private Text configValue;

    @Override
    public String getFxmlPath() {
        return FXML_PATH;
    }
    
    @Override
    public void componentDidMount() {
        if (configDefinition != null) {
            configDescription.setText(configDefinition.getConfigDescription());
            configName.setText(configDefinition.getConfigName());
            configValue.setText(configDefinition.getConfigValue());
        }
    }

}
```
###### \java\seedu\todo\ui\components\Console.java
``` java
public class Console extends Component {

    private static final String FXML_PATH = "components/Console.fxml";
    private static final String INVALID_COMMAND_RESPONSE = "Invalid command!";
    private static final String INVALID_COMMAND_STYLECLASS = "invalid";

    // Props
    public String consoleOutput;
    public String consoleInputValue;
    private String lastCommandEntered;
    
    // Input handler
    private InputHandler inputHandler = InputHandler.getInstance();
    
    // FXML
    @FXML
    private TextField consoleInputTextField;
    @FXML
    private TextArea consoleTextArea;


    @Override
    public String getFxmlPath() {
        return FXML_PATH;
    }

    @Override
    public void componentDidMount() {
        // Makes ConsoleInput full width wrt parent container.
        FxViewUtil.makeFullWidth(this.mainNode);
        
        // Set text in ConsoleInput box if provided
        if (consoleInputValue.length() > 0) {
            consoleInputTextField.setText(consoleInputValue);
            
            // Add invalid field css
            consoleInputTextField.getStyleClass().add(INVALID_COMMAND_STYLECLASS);
        } else {
            // Remove invalid field css
            consoleInputTextField.getStyleClass().remove(INVALID_COMMAND_STYLECLASS);
        }
        
        // Load ConsoleDisplay text.
        consoleTextArea.setText(consoleOutput);
    }

    /** ================ ACTION HANDLERS ================== **/
    @FXML
    public void handleConsoleInputKeyPress(KeyEvent event) {
        if (event.getCode() == KeyCode.UP) {
            String command = inputHandler.getPreviousCommandFromHistory();
            consoleInputTextField.setText(command);
        } else if (event.getCode() == KeyCode.DOWN) {
            String command = inputHandler.getNextCommandFromHistory();
            consoleInputTextField.setText(command);
        } else if (!event.getCode().isModifierKey()) {
            // Handle key accelerators in main scene if defined
            Runnable r = UiManager.getInstance().getMainWindow().getScene()
                    .getAccelerators().get(new KeyCodeCombination(event.getCode()));
            
            if (r != null) {
                r.run();
            }
        }
    }
    
    @FXML
    public void handleConsoleInputChanged() {
        lastCommandEntered = consoleInputTextField.getText();
        
        // Don't change anything if our command is empty.
        if (lastCommandEntered.length() <= 0) {
            return;
        }
        
        assert lastCommandEntered.length() > 0;
        
        boolean isValidCommand = inputHandler.processInput(lastCommandEntered);
        
        if (!isValidCommand) {
            // Show invalid response in Console
            consoleTextArea.setText(INVALID_COMMAND_RESPONSE);
            
            // Set CSS
            consoleInputTextField.getStyleClass().add(INVALID_COMMAND_STYLECLASS);
        } else {
            // Remove console output
            consoleTextArea.setText("");
            
            // Remove CSS
            consoleInputTextField.getStyleClass().remove(INVALID_COMMAND_STYLECLASS);
            
            // Clear input text
            consoleInputTextField.clear();
        }
    }
}
```
###### \java\seedu\todo\ui\components\Header.java
``` java
public class Header extends Component {

    private static final String LOGO_IMAGE_PATH = "/images/logo-64x64.png";
    private static final String FXML_PATH = "components/Header.fxml";
    private static final String VERSION_TEXT = "version ";
    
    // Props
    public String versionString;
    public String appTitle;

    // FXML
    @FXML
    private Text headerAppTitle;
    @FXML
    private Text headerVersionText;
    @FXML
    private ImageView headerLogoImageView;

    @Override
    public String getFxmlPath() {
        return FXML_PATH;
    }

    @Override
    public void componentDidMount() {
        // Makes the Component full width wrt parent container.
        FxViewUtil.makeFullWidth(this.mainNode);

        // Set text.
        headerAppTitle.setText(appTitle);
        headerVersionText.setText(VERSION_TEXT + versionString);

        // Set logo image.
        Image image = new Image(LOGO_IMAGE_PATH);
        headerLogoImageView.setImage(image);
    }

}
```
###### \java\seedu\todo\ui\components\HelpCommandItem.java
``` java
public class HelpCommandItem extends MultiComponent {

    private static final String FXML_PATH = "components/HelpCommandItem.fxml";
    
    // Props
    public String commandName;
    public String commandDescription;
    public String commandSyntax;
    
    // FXML
    @FXML
    private Text commandNameText;
    @FXML
    private Text commandDescriptionText;
    @FXML
    private Text commandSyntaxText;

    
    @Override
    public String getFxmlPath() {
        return FXML_PATH;
    }
    
    @Override
    public void componentDidMount() {
        commandNameText.setText(commandName);
        commandDescriptionText.setText(commandDescription);
        commandSyntaxText.setText(commandSyntax);
    }

}
```
###### \java\seedu\todo\ui\components\MultiComponent.java
``` java
/**
 * A MultiComponent is a special type of {@link Component}, except that 
 * the render method behaves differently. Successive calls to {@code render()}
 * would cause the node to the rendered to the placeholder multiple times, 
 * instead of replacing the old node. This is especially useful for 
 * rendering lists of variable items, using a loop.
 */
public abstract class MultiComponent extends Component {

    @Override
    public void render() {
        if (placeHolderPane != null) {
            // Replace placeholder children with node.
            placeHolderPane.getChildren().add(mainNode);
        }

        // Callback once view is loaded.
        componentDidMount();
    }

    /**
     * Resets the items in the specified {@code placeholder}.
     * 
     * @param placeholder    Placeholder pane whose children items are to be cleared.
     */
    public static void reset(Pane placeholder) {
        placeholder.getChildren().clear();
    }

}
```
###### \java\seedu\todo\ui\components\Sidebar.java
``` java
public class Sidebar extends Component {

    private static final String FXML_PATH = "components/Sidebar.fxml";

    // Links
    private static final String TASKS_LABEL = "Tasks";
    private static final String TASKS_ICON_PATH = "/images/icon-pin.png";
    private static final String OVERDUE_LABEL = "Overdue Tasks";
    private static final String OVERDUE_ICON_PATH = "/images/icon-siren.png";
    private static final String EVENTS_LABEL = "Events";
    private static final String EVENTS_ICON_PATH = "/images/icon-calendar.png";

    private static final String TAG_LABEL = "Tags";
    
    // Props
    public List<String> tags = new ArrayList<>();

    // FXML
    @FXML
    private Text titleText;
    @FXML
    private VBox sidebarCountersPlaceholder;
    @FXML
    private VBox sidebarTagsPlaceholder;

   @Override
    public String getFxmlPath() {
        return FXML_PATH;
    }

    @Override
    public void componentDidMount() {
        titleText.setText(formatTagSize(tags.size()));

        // Load Counters
        loadCounters();

        // Load Tags
        loadTags();
    }
    
    private String formatTagSize(int size) {
        return String.format("%s (%s)",TAG_LABEL, size);
    }
    
    private void loadCounters() {
        TodoListDB db = TodoListDB.getInstance();
        
        // Clear items.
        SidebarCounter.reset(sidebarCountersPlaceholder);

        String[] linkLabels = { formatLink(TASKS_LABEL, db.countIncompleteTasks()), 
                                formatLink(OVERDUE_LABEL, db.countOverdueTasks()), 
                                formatLink(EVENTS_LABEL , db.countFutureEvents()) };
        String[] linkIconPaths = { TASKS_ICON_PATH, OVERDUE_ICON_PATH, EVENTS_ICON_PATH };

        for (int i = 0; i < linkLabels.length; i++) {
            SidebarCounter counter = load(primaryStage, sidebarCountersPlaceholder, SidebarCounter.class);
            counter.label = linkLabels[i];
            counter.iconPath = linkIconPaths[i];
            counter.render();
        }
    }

    private void loadTags() {
        TagListItem.reset(sidebarTagsPlaceholder);

        for (String tag : tags) {
            TagListItem item = load(primaryStage, sidebarTagsPlaceholder, TagListItem.class);
            item.tag = tag;
            item.render();
        }
    }
    
    private String formatLink(String label, int total) {
        return String.format("%s (%d)", label, total);
    }

}
```
###### \java\seedu\todo\ui\components\SidebarCounter.java
``` java
public class SidebarCounter extends MultiComponent {

    private static final String FXML_PATH = "components/SidebarCounter.fxml";

    // Props
    public String iconPath;
    public String label;

    // FXML
    @FXML
    private ImageView imageView;
    @FXML
    private Text labelText;

    @Override
    public String getFxmlPath() {
        return FXML_PATH;
    }

    @Override
    public void componentDidMount() {
        imageView.setImage(new Image(iconPath));
        labelText.setText(label);
    }

}
```
###### \java\seedu\todo\ui\components\TagListItem.java
``` java
public class TagListItem extends MultiComponent {

    private static final String FXML_PATH = "components/TagListItem.fxml";
    private static final Color BULLET_COLOR = Color.rgb(0, 0, 0, 0.3);

    // Props
    public String tag;

    // FXML
    @FXML
    private Text labelText;
    @FXML
    private Circle labelBullet;

    @Override
    public String getFxmlPath() {
        return FXML_PATH;
    }

    @Override
    public void componentDidMount() {
        labelText.setText(tag);
        labelBullet.setFill(BULLET_COLOR);
    }

}
```
###### \java\seedu\todo\ui\components\TaskList.java
``` java
public class TaskList extends Component {
    
    public static final LocalDateTime NO_DATE_VALUE = LocalDateTime.MIN;

    private static final String FXML_PATH = "components/TaskList.fxml";
    private static EphemeralDB ephemeralDb = EphemeralDB.getInstance();

    // Props
    public List<Task> tasks = new ArrayList<>();
    public List<Event> events = new ArrayList<>();

    // FXML
    @FXML
    private VBox taskListDateItemsPlaceholder;

    @Override
    public String getFxmlPath() {
        return FXML_PATH;
    }

    @Override
    public void componentDidMount() {
        loadTasks();
    }

    private void loadTasks() {
        TaskListDateItem.reset(taskListDateItemsPlaceholder);

        // Clears displayedCalendarItems in EphemeralDB.
        ephemeralDb.clearDisplayedCalendarItems();

        // Get a list of tasks mapped to each date
        Map<LocalDateTime, ArrayList<Task>> tasksByDate = getItemsByDate(tasks);
        Map<LocalDateTime, ArrayList<Event>> eventsByDate = getItemsByDate(events);

        // Get unique task/event dates
        Set<LocalDateTime> uniqueDateSet = new HashSet<>();
        uniqueDateSet.addAll(tasksByDate.keySet());
        uniqueDateSet.addAll(eventsByDate.keySet());
        
        // Sort the dates
        List<LocalDateTime> sortedUniqueDates = new ArrayList<>();
        sortedUniqueDates.addAll(uniqueDateSet);
        java.util.Collections.sort(sortedUniqueDates);

        // For each dateTime, individually render a single TaskListDateItem.
        for (LocalDateTime dateTime : sortedUniqueDates) {
            List<Task> tasksForDate = tasksByDate.get(dateTime);
            List<Event> eventsForDate = eventsByDate.get(dateTime);
            
            TaskListDateItem item = load(primaryStage, taskListDateItemsPlaceholder, TaskListDateItem.class);
            item.dateTime = dateTime;
            
            if (tasksForDate != null) {
                item.tasks = tasksForDate;
            }
            
            if (eventsForDate != null) {
                item.events = eventsForDate;
            }
            
            item.render();
        }
    }

    private <T extends CalendarItem> Map<LocalDateTime, ArrayList<T>> getItemsByDate(List<T> calendarItems) {
        Map<LocalDateTime, ArrayList<T>> itemsByDate = new HashMap<>();

        for (T item : calendarItems) {
            LocalDateTime itemDate = DateUtil.floorDate(item.getCalendarDateTime());
            
            // Handle tasks without a date
            if (itemDate == null) {
                itemDate = NO_DATE_VALUE;
            }

            // Creates ArrayList if not already exists.
            if (!itemsByDate.containsKey(itemDate)) {
                itemsByDate.put(itemDate, new ArrayList<T>());
            }
            
            // Adds to the ArrayList.
            itemsByDate.get(itemDate).add(item);
        }

        return itemsByDate;
    }

}
```
###### \java\seedu\todo\ui\components\TaskListDateItem.java
``` java
public class TaskListDateItem extends MultiComponent {

    private static final String FXML_PATH = "components/TaskListDateItem.fxml";
    private static EphemeralDB ephemeralDb = EphemeralDB.getInstance();
    private static final String NO_DATE_STRING = "No Deadline";

    // Props
    public LocalDateTime dateTime;
    public List<Task> tasks = new ArrayList<>();
    public List<Event> events = new ArrayList<>();

    // FXML
    @FXML
    private Text dateHeader;
    @FXML
    private Text dateLabel;
    @FXML
    private VBox dateCalendarItemsPlaceholder;

    @Override
    public String getFxmlPath() {
        return FXML_PATH;
    }

    @Override
    public void componentDidMount() {
        
        // Set header for DateItem using the "x days ago" format
        String dateHeaderString;
        if (dateTime == TaskList.NO_DATE_VALUE) {
            dateHeaderString = NO_DATE_STRING;
        } else {
            dateHeaderString = DateUtil.formatDay(dateTime);
        }

        dateHeader.setText(dateHeaderString);
        
        // Set date label using the short date format (e.g. Fri 14 Oct)
        if (dateTime != TaskList.NO_DATE_VALUE) {
            String dateLabelString = DateUtil.formatShortDate(dateTime);
            dateLabel.setText(dateLabelString);
        }

        // Clear the TaskList of its items
        TaskListTaskItem.reset(dateCalendarItemsPlaceholder);

        // Load task and event items
        loadEventItems();
        loadTaskItems();
    }

    private void loadTaskItems() {
        for (Task task : tasks) {
            TaskListTaskItem item = load(primaryStage, dateCalendarItemsPlaceholder, TaskListTaskItem.class);

            // Add to EphemeralDB and get the index.
            int displayIndex = ephemeralDb.addToDisplayedCalendarItems(task);

            // Set the props and render the TaskListTaskItem.
            item.task = task;
            item.displayIndex = displayIndex;
            item.render();
        }
    }
    
    private void loadEventItems() {
        for (Event event : events) {
            TaskListEventItem item = load(primaryStage, dateCalendarItemsPlaceholder, TaskListEventItem.class);

            // Add to EphemeralDB and get the index.
            int displayIndex = ephemeralDb.addToDisplayedCalendarItems(event);

            // Set the props and render the TaskListTaskItem.
            item.event = event;
            item.displayIndex = displayIndex;
            item.render();
        }
    }

}
```
###### \java\seedu\todo\ui\components\TaskListEventItem.java
``` java
public class TaskListEventItem extends MultiComponent {

    private static final String FXML_PATH = "components/TaskListEventItem.fxml";
    private static final String ICON_PATH = "/images/icon-calendar.png";
    
    // Props
    public Event event;
    public Integer displayIndex;

    // FXML
    @FXML
    private Text eventText;
    @FXML
    private Text eventTime;
    @FXML
    private Text rowIndex;
    @FXML
    private ImageView rowIconImageView;
    @FXML
    private Text eventTagListText;
    
    @Override
    public String getFxmlPath() {
        return FXML_PATH;
    }

    @Override
    public void componentDidMount() {
        eventText.setText(event.getName());
        eventTime.setText(DateUtil.formatDateFromTo(event.getStartDate(), event.getEndDate()));
        rowIndex.setText(displayIndex.toString());
        eventTagListText.setText(StringUtil.checkEmptyList(event.getTagList())); //TODO : Change FXML file to support TagList
        
        // Set image
        rowIconImageView.setImage(new Image(ICON_PATH));
        
        // If over, set style
        if (event.isOver()) {
            eventText.getStyleClass().add("completed");
        }
    }

}
```
###### \java\seedu\todo\ui\components\TaskListTaskItem.java
``` java
public class TaskListTaskItem extends MultiComponent {

    private static final String COMPLETED_ICON_PATH = "/images/icon-tick.png";
    private static final String FXML_PATH = "components/TaskListTaskItem.fxml";
    
    // Props
    public Task task;
    public Integer displayIndex;

    // FXML
    @FXML
    private Text taskText;
    @FXML
    private Text taskTime;
    @FXML
    private Text rowIndex;
    @FXML
    private Circle taskCheckMarkCircle;
    @FXML
    private ImageView taskCheckMarkImage;
    @FXML
    private Text taskTagListText;

    @Override
    public String getFxmlPath() {
        return FXML_PATH;
    }

    @Override
    public void componentDidMount() {
        rowIndex.setText(displayIndex.toString());
        taskText.setText(task.getName());
        taskTagListText.setText(StringUtil.checkEmptyList(task.getTagList())); 
        
        LocalDateTime dateTime = task.getCalendarDateTime();
        if (dateTime != null) {
            taskTime.setText(DateUtil.formatTime(dateTime));
        }
        
        if (task.isCompleted()) {
            showCompleted();
        } else {
            showIncomplete();
        }
    }
    
    private void showCompleted() {
        taskCheckMarkImage.setImage(new Image(COMPLETED_ICON_PATH));
        taskCheckMarkCircle.setRadius(0);
        taskText.getStyleClass().add("completed");
    }
    
    private void showIncomplete() {
        taskCheckMarkImage.setFitWidth(0);
    }

}
```
###### \java\seedu\todo\ui\InputHandler.java
``` java
/**
 * InputHandler is the bridge between the UI, or more 
 * specifically the Console, and the Controllers. 
 * 
 * It will match the correct Controller to handle the command
 * based on the command words.
 * 
 * It will also maintain a command history (similar to that of a
 * terminal console) where the user can interact with using
 * up and down arrow keys.
 */
public class InputHandler {
    
    private static InputHandler instance;
    
    private static final int MAX_HISTORY_SIZE = 20;
    private static LinkedList<String> commandHistory = new LinkedList<String>();
    private static ListIterator<String> commandHistoryIterator = commandHistory.listIterator();

    private static final String CHAR_SPACE = " ";
    
    protected InputHandler() {
        // Prevent instantiation.
    }
    
    /**
     * Gets the current input handler instance.
     */
    public static InputHandler getInstance() {
        if (instance == null) {
            instance = new InputHandler();
        }
        
        return instance;
    }
    
    /**
     * Pushes a command to the end of a LinkedList.
     * Commands are stored like a queue, where the oldest items 
     * are at the start of the List and will be popped off first.
     * 
     * @param command   Command string
     */
    private void pushCommand(String command) {
        // Adds to the end of the LinkedList.
        commandHistory.addLast(command);
        
        // Truncates the list when it gets too big.
        if (commandHistory.size() > MAX_HISTORY_SIZE) {
            commandHistory.removeFirst();
        }
        
        // Create a new iterator, initialize position to point right at the end.
        commandHistoryIterator = commandHistory.listIterator(commandHistory.size());
    }
    
    /**
     * Gets the previous command from the command history. Successive calls will return commands earlier in history.
     * 
     * @return  The input command earlier than what was previously retrieved
     */
    public String getPreviousCommandFromHistory() {
        if (!commandHistoryIterator.hasPrevious()) {
            return "";
        }
        
        return commandHistoryIterator.previous();
    }
    
    /**
     * Gets the next command from the command history. Successive calls will return commands later in history.
     * 
     * @return  The input command later than what was previously retrieved
     */
    public String getNextCommandFromHistory() {
        if (!commandHistoryIterator.hasNext()) {
            return "";
        }
        
        return commandHistoryIterator.next();
    }

    /**
     * Processes the command. Returns true if the command was intercepted by a controller, false if otherwise.
     * If the command was not intercepted by a controller, it means that the command was not recognized.
     */
    public boolean processInput(String input) {
        
        Map<String, String> aliases = ConfigCenter.getInstance().getConfig().getAliases();
        String aliasedInput = StringUtil.replaceAliases(input, aliases);
        
        Controller[] controllers = instantiateAllControllers();
        
        // Extract keyword.
        String keyword = extractKeyword(aliasedInput);

        // Get controller which has the maximum confidence.
        Controller matchingController = getMatchingController(keyword, controllers);

        // If command keyword did not match any controllers, console will show invalid command.
        if (matchingController == null) {
            return false;
        }
        
        // Patch input commands.
        input = patchCommandKeyword(input);
        aliasedInput = patchCommandKeyword(aliasedInput);
        
        // Process using matched controller.
        boolean isProcessSuccess = processWithController(input, aliasedInput, matchingController);
        
        // Catch commands which throw errors here.
        if (!isProcessSuccess) {
            return false;
        }
        
        // Since command is not invalid, we push it to history
        pushCommand(aliasedInput);

        return true;
    }

    /**
     * Process an input/aliasedInput with a selected controller.
     * 
     * Note that for proper functioning, <code>alias</code> and
     * <code>unalias</code> will receive the <code>input</code> instead of
     * <code>aliasedInput</code> for proper functioning.
     * 
     * @param input                 Raw user input
     * @param aliasedInput          Input with aliases replaced
     * @param selectedController    Controller to process input
     * @return                      true if processing was successful, false otherwise
     */
    private boolean processWithController(String input, String aliasedInput, Controller selectedController) {
        try {
            // Alias and unalias should not receive an aliasedInput for proper functioning.
            if (selectedController.getClass() == AliasController.class ||
                    selectedController.getClass() == UnaliasController.class) {
                selectedController.process(input);
            } else {
                selectedController.process(aliasedInput);
            }
            return true;
        } catch (ParseException e) {
            return false;
        }
    }

    /**
     * Get controller which matches the command keyword.
     * 
     * @param aliasedCommandKeyword  Input with aliases replaced appropriately
     * @param controllers   Array of instantiated controllers to test
     * @return              Matching controller.
     */
    private Controller getMatchingController(String aliasedCommandKeyword, Controller[] controllers) {
        for (Controller controller : controllers) {
            if (controller.matchCommandKeyword(aliasedCommandKeyword)) {
                return controller;
            }
        }
        
        return null;
    }
    
    /**
     * Extracts the command keyword from the input command.
     */
    private String extractKeyword(String inputCommand) {
        String[] commandWords = inputCommand.trim().split(CHAR_SPACE);
        
        if (commandWords.length < 1) {
            return "";
        }
        
        return commandWords[0].toLowerCase();
    }
    
    /**
     * Replaces the first word in a command input string to prepare it for parsing and/or disambiguating.
     */
    private String patchCommandKeyword(String inputCommand) {
        String[] commandWords = inputCommand.trim().split(CHAR_SPACE);
        
        if (commandWords.length < 1) {
            return "";
        } else {
            commandWords[0] = extractKeyword(inputCommand);
        }
        
        return String.join(CHAR_SPACE, commandWords);
    }
    
    private static Controller[] instantiateAllControllers() {
        return new Controller[] { new AliasController(),
                                  new UnaliasController(),
                                  new HelpController(),
                                  new AddController(),
                                  new ListController(),
                                  new DestroyController(),
                                  new CompleteTaskController(),
                                  new UncompleteTaskController(),
                                  new UpdateController(),
                                  new UndoController(),
                                  new RedoController(),
                                  new ConfigController(),
                                  new ClearController(),
                                  new FindController(),
                                  new TagController(),
                                  new UntagController(),
                                  new ExitController() };
    }

}
```
###### \java\seedu\todo\ui\MainWindow.java
``` java
/**
 * The Main Window. Provides the basic application layout containing
 * a menu bar and space where other JavaFX elements can be placed.
 */
public class MainWindow extends Component {

    private static final String FXML_PATH = "MainWindow.fxml";
    private static final String ICON_PATH = "/images/logo-512x512.png";
    public static final int MIN_HEIGHT = 600;
    public static final int MIN_WIDTH = 600;
    
    private static final String COMMAND_HELP = "help";
    private static final String COMMAND_LIST = "list";
    private static final String COMMAND_CONFIG = "config";
    private static final String COMMAND_ALIAS = "alias";

    private static final String KEY_OPEN_HELP = "F1";
    private static final String KEY_OPEN_LIST = "F5";
    private static final String KEY_OPEN_CONFIG = "F12";

    // Handles to elements of this Ui container
    private VBox rootLayout;
    private Scene scene;

    // FXML Components
    @FXML
    private AnchorPane childrenPlaceholder;
    @FXML
    private AnchorPane consoleInputPlaceholder;
    @FXML
    private AnchorPane headerPlaceholder;
    @FXML
    private MenuItem homeMenuItem;
    @FXML
    private MenuItem configMenuItem;
    @FXML
    private MenuItem helpMenuItem;

    public void configure(Config config) {
        String appTitle = config.getAppTitle();

        // Configure the UI
        setTitle(appTitle);
        setIcon(ICON_PATH);
        setWindowMinSize();
        scene = new Scene(rootLayout);
        primaryStage.setScene(scene);

        // Bind accelerators
        setAccelerators();

        // Load other components.
        loadComponents();
    }

    protected void loadComponents() {
        // Load Header
        Header header = UiPartLoader.loadUiPart(primaryStage, getHeaderPlaceholder(), Header.class);
        header.appTitle = ConfigCenter.getInstance().getConfig().getAppTitle();
        header.versionString = MainApp.VERSION.toString();
        header.render();

        // Load ConsoleInput
        Console console = UiPartLoader.loadUiPart(primaryStage, getConsoleInputPlaceholder(), Console.class);
        console.consoleOutput = UiManager.getConsoleMessage();
        console.consoleInputValue = UiManager.getConsoleInputValue();
        console.render();
    }

    @Override
    public void setNode(Node node) {
        rootLayout = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML_PATH;
    }

    public void show() {
        primaryStage.show();
    }

    public void hide() {
        primaryStage.hide();
    }

    public void setTitle(String appTitle) {
        primaryStage.setTitle(appTitle);
    }

    public void setWindowMinSize() {
        primaryStage.setMinHeight(MIN_HEIGHT);
        primaryStage.setMinWidth(MIN_WIDTH);
    }

    protected <T extends View> T loadView(Class<T> viewClass) {
        return load(primaryStage, getChildrenPlaceholder(), viewClass);
    }
    
    public Scene getScene() {
        return scene;
    }

    /** ================ FXML COMPONENTS ================== **/

    public AnchorPane getChildrenPlaceholder() {
        return childrenPlaceholder;
    }

    public AnchorPane getConsoleInputPlaceholder() {
        return consoleInputPlaceholder;
    }

    public AnchorPane getHeaderPlaceholder() {
        return headerPlaceholder;
    }

    /** ================ ACCELERATORS ================== **/

    private void setAccelerators() {
        helpMenuItem.setAccelerator(KeyCombination.valueOf(KEY_OPEN_HELP));
        homeMenuItem.setAccelerator(KeyCombination.valueOf(KEY_OPEN_LIST));
        configMenuItem.setAccelerator(KeyCombination.valueOf(KEY_OPEN_CONFIG));
    }

    /** ================ ACTION HANDLERS ================== **/
    
    @FXML
    public void handleHelp() {
        // Pass directly to HelpController.
        new HelpController().process(COMMAND_HELP);
    }

    @FXML
    public void handleHome() {
        // Pass directly to ListController.
        try {
            new ListController().process(COMMAND_LIST);
        } catch (ParseException e) {
            return;
        }
    }
    
    @FXML
    public void handleConfig() {
        // Pass directly to HelpController.
        new ConfigController().process(COMMAND_CONFIG);
    }
    
    @FXML
    public void handleAlias() {
        // Pass directly to HelpController.
        new AliasController().process(COMMAND_ALIAS);
    }

    @FXML
    private void handleExit() {
        raise(new ExitAppRequestEvent());
    }
}
```
###### \java\seedu\todo\ui\UiManager.java
``` java
/**
 * The manager of the UI component.
 * 
 * Singleton class for other modules to interact
 * with the UI. Provides two methods {@code loadView} and
 * {@code renderView}, which generate a view controller
 * and subsequently rendering it after passing/binding
 * relevant properties.
 */
public class UiManager extends ComponentManager implements Ui {
    private static final Logger logger = LogsCenter.getLogger(UiManager.class);

    // Only one instance of UiManager should be present. 
    private static UiManager instance = null;
    
    // Only one currentView.
    public static View currentView;
    
    private static String currentConsoleMessage = "";
    private static String currentConsoleInputValue = "";

    private Config config;
    private MainWindow mainWindow;
    
    private static final String FATAL_ERROR_DIALOG = "Fatal error during initializing";
    private static final String LOAD_VIEW_ERROR = "Cannot loadView: UiManager not instantiated.";
    
    protected UiManager() {
        // Prevent instantiation.
    }

    public static UiManager getInstance() {
        return instance;
    }

    public static void initialize(Config config) {
        if (instance == null) {
            instance = new UiManager();
        }
        
        instance.config = config;
    }

    @Override
    public void start(Stage primaryStage) {
        logger.info("Starting UI...");

        // Show main window.
        try {
            mainWindow = UiPartLoader.loadUiPart(primaryStage, null, MainWindow.class);
            mainWindow.configure(config);
            mainWindow.render();
            mainWindow.show();
        } catch (Throwable e) {
            logger.severe(StringUtil.getDetails(e));
            showFatalErrorDialogAndShutdown(FATAL_ERROR_DIALOG, e);
        }
    }

    @Override
    public void stop() {
        mainWindow.hide();
    }
    
    public MainWindow getMainWindow() {
        return mainWindow;
    }

    /**
     * Helper function to load view into the MainWindow.
     */
    public static <T extends View> T loadView(Class<T> viewClass) {
        if (instance == null) {
            logger.warning(LOAD_VIEW_ERROR);
            return null;
        }
        
        return instance.mainWindow.loadView(viewClass);
    }
    
    /**
     * Updates the currentView and renders it.
     * 
     * @param view   View to render.
     */
    public static void renderView(View view) {
        if (view != null && view.getNode() != null) {
            currentView = view;
            
            // Clear console values first
            currentConsoleInputValue = "";
            currentConsoleMessage = "";
            
            // Render view
            view.render();
        }
    }
    
    public static String getConsoleMessage() {
        return currentConsoleMessage;
    }
    
    public static String getConsoleInputValue() {
        return currentConsoleInputValue;
    }
    
    /**
     * Sets the message shown in the console and reloads the console box.
     * Does not do anything if no views have been loaded yet.
     * 
     * @param consoleMessage   Message to display in the console.
     */
    public static void updateConsoleMessage(String consoleMessage) {
        if (currentView != null) {
            currentConsoleMessage = consoleMessage;
            instance.mainWindow.loadComponents();
        }
    }
    
    /**
     * Sets the message shown in the console input box and reloads the console box.
     * Does not do anything if no views have been loaded yet.
     * 
     * @param consoleInputValue   Message to display in the console input box.
     */
    public static void updateConsoleInputValue(String consoleInputValue) {
        if (currentView != null) {
            currentConsoleInputValue = consoleInputValue;
            instance.mainWindow.loadComponents();
        }
    }


    /** ================ DISPLAY ERRORS ================== **/

    private void showAlertDialogAndWait(Alert.AlertType type, String title, String headerText, String contentText) {
        showAlertDialogAndWait(mainWindow.getPrimaryStage(), type, title, headerText, contentText);
    }

    private static void showAlertDialogAndWait(Stage owner, AlertType type, String title, String headerText,
            String contentText) {
        final Alert alert = new Alert(type);
        alert.initOwner(owner);
        alert.setTitle(title);
        alert.setHeaderText(headerText);
        alert.setContentText(contentText);

        alert.showAndWait();
    }

    private void showFatalErrorDialogAndShutdown(String title, Throwable e) {
        logger.severe(title + " " + e.getMessage() + StringUtil.getDetails(e));
        showAlertDialogAndWait(Alert.AlertType.ERROR, title, e.getMessage(), e.toString());
        Platform.exit();
        System.exit(1);
    }

}
```
###### \java\seedu\todo\ui\UiPartLoader.java
``` java
/**
 * A utility class to load UiParts from FXML files.
 * Modified from original codebase to support two-step
 * loading and rendering (see {@link UiManager}).
 */
public class UiPartLoader {
    private final static String FXML_FILE_FOLDER = "/ui/";
    private final static String FXML_ERROR_MESSAGE = "FXML Load Error for ";
    private final static String INSTANTION_EXCEPTION_ERROR_MESSAGE = "Could not instantiate ";
    
    /**
     * Loads the UiPart and returns the view controller.
     *
     * @param primaryStage The primary stage for the view.
     * @param placeholder  The placeholder where the loaded Ui Part is added.
     * @param uiPartClass  The UiPart class to load.
     * @param <T>          The type of the UiPart
     */
    public static <T extends UiPart> T loadUiPart(Stage primaryStage, Pane placeholder, Class<T> uiPartClass) {
        FXMLLoader loader = new FXMLLoader();
        
        // Get FXML path
        T instance = null;
        try {
            instance = uiPartClass.newInstance();
        } catch (InstantiationException | IllegalAccessException e) {
            String errorMessage = INSTANTION_EXCEPTION_ERROR_MESSAGE + uiPartClass.getName();
            throw new RuntimeException(errorMessage, e);
        }
        String fxmlPath = instance.getFxmlPath();
        
        // Continue with loading
        loader.setLocation(getFXMLResource(fxmlPath));
        Node mainNode = loadLoader(loader, fxmlPath);

        T controller = loader.getController();
        controller.setStage(primaryStage);
        controller.setPlaceholder(placeholder);
        controller.setNode(mainNode);
        return controller;
    }


    private static Node loadLoader(FXMLLoader loader, String fxmlFileName) {
        try {
            return loader.load();
        } catch (Exception e) {
            String errorMessage = FXML_ERROR_MESSAGE + fxmlFileName;
            throw new RuntimeException(errorMessage, e);
        }
    }

    private static URL getFXMLResource(String fxmlPath) {
        return MainApp.class.getResource(FXML_FILE_FOLDER + fxmlPath);
    }

}
```
###### \java\seedu\todo\ui\views\ConfigView.java
``` java
/**
 * Config View, which shows the list of settings that can be configured.
 */
public class ConfigView extends View {

    private static final String FXML_PATH = "views/ConfigView.fxml";

    private static final String ICON_PATH = "/images/icon-settings.png";
    private static final String TEXT_INSTRUCTIONS = "To change a setting, use the following command:\n    config SETTING VALUE";

    // FXML
    @FXML
    private Text configInstructionsText;
    @FXML
    private ImageView configImageView;
    @FXML
    private Pane configsPlaceholder;

    @Override
    public String getFxmlPath() {
        return FXML_PATH;
    }

    @Override
    public void componentDidMount() {
        // Makes the Component full width wrt parent container.
        FxViewUtil.makeFullWidth(this.mainNode);
        
        // Set instructions
        configInstructionsText.setText(TEXT_INSTRUCTIONS);

        // Load image
        configImageView.setImage(new Image(ICON_PATH));
        
        // Get definitions
        List<ConfigDefinition> configDefinitions = ConfigCenter.getInstance().getConfig().getDefinitions();

        // Clear items
        ConfigItem.reset(configsPlaceholder);

        // Load items
        for (ConfigDefinition definition : configDefinitions) {
            ConfigItem item = load(primaryStage, configsPlaceholder, ConfigItem.class);
            item.configDefinition = definition;
            item.render();
        }
    }

}
```
###### \java\seedu\todo\ui\views\HelpView.java
``` java
/**
 * Help View, which shows all the commands available.
 */
public class HelpView extends View {

    private static final String FXML_PATH = "views/HelpView.fxml";
    
    // Props
    public List<CommandDefinition> commandDefinitions = new ArrayList<CommandDefinition>();
    
    // FXML
    @FXML
    private Pane helpCommandsPlaceholder;

    @Override
    public String getFxmlPath() {
        return FXML_PATH;
    }
    
    @Override
    public void componentDidMount() {
        // Makes the Component full width wrt parent container.
        FxViewUtil.makeFullWidth(this.mainNode);
        
        // Clear help commands
        HelpCommandItem.reset(helpCommandsPlaceholder);
        
        // Load help commands
        for (CommandDefinition command : commandDefinitions) {
            HelpCommandItem item = load(primaryStage, helpCommandsPlaceholder, HelpCommandItem.class);
            item.commandName = command.getCommandName();
            item.commandDescription = command.getCommandDescription();
            item.commandSyntax = command.getCommandSyntax();
            item.render();
        }
    }
    

}
```
###### \java\seedu\todo\ui\views\IndexView.java
``` java
/**
 * Index View, which shows the list of tasks and tags in a two-column format.
 */
public class IndexView extends View {

    private static final String FXML_PATH = "views/IndexView.fxml";

    // FXML
    @FXML
    private Pane tagsPane;
    @FXML
    private Pane tasksPane;

    // Props
    public List<Event> events = new ArrayList<>();
    public List<Task> tasks = new ArrayList<>();
    public List<String> tags = new ArrayList<>();

    @Override
    public String getFxmlPath() {
        return FXML_PATH;
    }

    @Override
    public void componentDidMount() {
        // Makes full width wrt parent container.
        FxViewUtil.makeFullWidth(this.mainNode);

        // Load sub components
        loadComponents();
    }

    private void loadComponents() {
        // Render TagList
        Sidebar tagList = load(primaryStage, tagsPane, Sidebar.class);
        tagList.tags = tags;
        tagList.render();

        // Render TaskList
        TaskList taskList = load(primaryStage, tasksPane, TaskList.class);
        taskList.tasks = tasks;
        taskList.events = events;
        taskList.render();
    }

}
```
###### \java\seedu\todo\ui\views\View.java
``` java
/**
 * A {@code View} is essentially a special type of Component, with no implementation 
 * differences at the moment. However, a {@code View} is the grouping of Components 
 * to form the whole UI experience. In the case of this app, the {@code View} corresponds 
 * with the portion between the Header and the Console. 
 * <br><br>
 * Different {@code View}s can be loaded depending on the context.
 */
public abstract class View extends Component {
    
}
```
###### \resources\ui\components\ConfigItem.fxml
``` fxml
<VBox fx:id="configItem" styleClass="tasklist-dateitem" maxHeight="Infinity" maxWidth="Infinity" minHeight="-Infinity" minWidth="-Infinity" 
  xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" 
  fx:controller="seedu.todo.ui.components.ConfigItem">
  <children>

    <HBox alignment="CENTER_LEFT">
      <children>
        <Text fx:id="configDescription" styleClass="font-500" wrappingWidth="150.0" VBox.vgrow="ALWAYS" />
        <Text fx:id="configName" wrappingWidth="150.0" VBox.vgrow="ALWAYS" />
        <Text fx:id="configValue" VBox.vgrow="ALWAYS" />
      </children>
    </HBox>
    
  </children>
  <padding>
    <Insets bottom="10.0" />
  </padding>
</VBox>
```
###### \resources\ui\components\Console.fxml
``` fxml
<VBox xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" 
  fx:controller="seedu.todo.ui.components.Console">
  
  <children>
    <TextArea fx:id="consoleTextArea" editable="false" focusTraversable="false" mouseTransparent="true"  
      promptText="Console text" styleClass="console-textarea" wrapText="true" />
    
    <TextField fx:id="consoleInputTextField" styleClass="console-input-textfield" onAction="#handleConsoleInputChanged" 
      onKeyPressed="#handleConsoleInputKeyPress" promptText="Enter command here..." VBox.vgrow="NEVER" />
  </children>
  
</VBox>

```
###### \resources\ui\components\Header.fxml
``` fxml
<VBox styleClass="header" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.todo.ui.components.Header">
  
  <children>
    <HBox>
      <children>
        <ImageView fitHeight="64.0" fitWidth="64.0" fx:id="headerLogoImageView" pickOnBounds="true" preserveRatio="true">
          <HBox.margin>
            <Insets top="15.0" left="10.0" />
          </HBox.margin>
        </ImageView>
        
        <VBox>
          <children>
          
            <Text fx:id="headerAppTitle" styleClass="font-300, header-text">
              <VBox.margin>
                <Insets bottom="5.0" left="10.0" right="10.0" top="20.0" />
              </VBox.margin>
            </Text>
            
            <Text fx:id="headerVersionText" styleClass="font-300, header-version-text">
              <VBox.margin>
                <Insets bottom="20.0" left="10.0" right="10.0" top="5.0" />
              </VBox.margin>
            </Text>
            
          </children>
        </VBox>
      </children>
    </HBox>
  </children>
  
</VBox>
```
###### \resources\ui\components\HelpCommandItem.fxml
``` fxml
<VBox fx:id="helpCommandItem" maxHeight="Infinity" maxWidth="Infinity" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.todo.ui.components.HelpCommandItem">
  <children>
    <Text fx:id="commandNameText" styleClass="font-300, commandtext-name">
      <VBox.margin>
        <Insets bottom="5.0" />
      </VBox.margin>
    </Text>
    <Text fx:id="commandSyntaxText" styleClass="commandtext-syntax">
      <VBox.margin>
        <Insets bottom="5.0" />
      </VBox.margin>
    </Text>
    <Text fx:id="commandDescriptionText" styleClass="commandtext-description">
      <VBox.margin>
        <Insets bottom="5.0" />
      </VBox.margin>
    </Text>
  </children>
  <VBox.margin>
    <Insets bottom="15.0" />
  </VBox.margin>
</VBox>
```
###### \resources\ui\components\Sidebar.fxml
``` fxml
<VBox maxHeight="Infinity" maxWidth="Infinity" minHeight="-Infinity" minWidth="-Infinity" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.todo.ui.components.Sidebar">
  <children>
    
    <VBox fx:id="sidebarCountersPlaceholder" />
  
    <Text fx:id="titleText" styleClass="font-300, taglist-title" text="Tags">
      <VBox.margin>
        <Insets left="5.0" top="20.0" />
      </VBox.margin>
    </Text>
  
    <VBox fx:id="sidebarTagsPlaceholder" />
    
  </children>
  <padding>
    <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
  </padding>
</VBox>
```
###### \resources\ui\components\SidebarCounter.fxml
``` fxml
<VBox maxHeight="Infinity" maxWidth="Infinity" minHeight="-Infinity" minWidth="-Infinity" 
  xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" 
  fx:controller="seedu.todo.ui.components.SidebarCounter">
  <children>
  
    <HBox styleClass="taglist-link">
      <children>
        <ImageView fitHeight="24.0" fitWidth="24.0" fx:id="imageView" styleClass="taglist-link-image" pickOnBounds="true" preserveRatio="true" />
        <Text fx:id="labelText" styleClass="font-300, taglist-link-text" HBox.hgrow="ALWAYS">
          <HBox.margin>
            <Insets left="10.0" top="3.0" />
          </HBox.margin>
        </Text>
      </children>
    </HBox>
    
  </children>
  <padding>
    <Insets bottom="10.0" left="5.0" right="20.0" top="10.0" />
  </padding>
</VBox>
```
###### \resources\ui\components\TagListItem.fxml
``` fxml
<VBox fx:id="tagListItem" maxHeight="Infinity" maxWidth="Infinity" minHeight="-Infinity" minWidth="-Infinity" 
  xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" 
  fx:controller="seedu.todo.ui.components.TagListItem">
  <children>
  
    <HBox styleClass="taglist-item">
      <children>
        <Circle fx:id="labelBullet" styleClass="taglist-item-bullet" radius="4">
          <HBox.margin>
            <Insets left="5.0" right="10.0" top="4.0" />
          </HBox.margin>
        </Circle>
        <Text fx:id="labelText" styleClass="taglist-item-text" HBox.hgrow="ALWAYS" />
      </children>
    </HBox>
    
  </children>
  <padding>
    <Insets left="5.0" right="20.0" top="10.0" />
  </padding>
</VBox>
```
###### \resources\ui\components\TaskList.fxml
``` fxml
<VBox maxHeight="Infinity" maxWidth="Infinity" minHeight="-Infinity" minWidth="-Infinity" 
  xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" 
  fx:controller="seedu.todo.ui.components.TaskList">
  <children>
    
    <VBox fx:id="taskListDateItemsPlaceholder" />
    
  </children>
  <padding>
    <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
  </padding>
</VBox>
```
###### \resources\ui\components\TaskListDateItem.fxml
``` fxml
<VBox id="taskListDateItem" fx:id="taskListDateItem" styleClass="tasklist-dateitem" maxHeight="Infinity" maxWidth="Infinity" minHeight="-Infinity" minWidth="-Infinity" 
  xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" 
  fx:controller="seedu.todo.ui.components.TaskListDateItem">
  <children>

    <HBox alignment="BOTTOM_LEFT">
      <children>
        <Text fx:id="dateHeader" styleClass="font-300, tasklist-dateitem-dateheader" VBox.vgrow="ALWAYS" />
        <Text fx:id="dateLabel" styleClass="tasklist-dateitem-datelabel" VBox.vgrow="ALWAYS">
          <HBox.margin>
            <Insets left="10.0" />
          </HBox.margin>
        </Text>
      </children>
      <VBox.margin>
        <Insets left="10.0" top="3.0" />
      </VBox.margin>
    </HBox>

    <VBox fx:id="dateCalendarItemsPlaceholder" />
    
  </children>
  <padding>
    <Insets bottom="10.0" left="5.0" right="20.0" top="10.0" />
  </padding>
</VBox>
```
###### \resources\ui\components\TaskListEventItem.fxml
``` fxml
<HBox fx:id="taskListEventItem" maxHeight="40.0" maxWidth="Infinity" minHeight="40.0" minWidth="-Infinity" 
  xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" 
  fx:controller="seedu.todo.ui.components.TaskListEventItem" alignment="CENTER_LEFT">
  <children>
  
    <Text fx:id="rowIndex" styleClass="tasklist-rowindex" HBox.hgrow="NEVER" wrappingWidth="20.0" />
    <ImageView fitHeight="20.0" fitWidth="20.0" fx:id="rowIconImageView" pickOnBounds="true" preserveRatio="true">
      <HBox.margin>
        <Insets right="10.0" />
      </HBox.margin>
    </ImageView>
    <VBox maxHeight="40.0" maxWidth="Infinity" minHeight="0.0" minWidth="-Infinity">
   		<children>
   	      <HBox maxHeight="30.0" maxWidth="Infinity" minHeight="10.0" minWidth="-Infinity">
   	        <children>
   	        	<Text fx:id="eventText" styleClass="tasklist-eventitem-label" HBox.hgrow="ALWAYS" />
			    <Text fx:id="eventTime" styleClass="tasklist-itemtime" HBox.hgrow="ALWAYS">
			      <HBox.margin>
			        <Insets left="10.0" />
			      </HBox.margin>
			    </Text>
   	        </children>
   	      </HBox>
   		  <HBox maxHeight="10.0" maxWidth="Infinity" minHeight="0.0" minWidth="-Infinity">
   		    <children>
   		      <Text fx:id="eventTagListText" styleClass="tasklist-itemtime" HBox.hgrow="ALWAYS" >
   		      <HBox.margin>
   		        <Insets top = "5.0" />
   		      </HBox.margin>
   		      </Text>
   		    </children>
   		  </HBox>
   		</children> 
    </VBox>
  </children>
  <padding>
    <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
  </padding>
</HBox>
```
###### \resources\ui\components\TaskListTaskItem.fxml
``` fxml
<HBox fx:id="taskListTaskItem" maxHeight="40.0" maxWidth="Infinity" minHeight="40.0" minWidth="-Infinity" 
  xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" 
  fx:controller="seedu.todo.ui.components.TaskListTaskItem" alignment="CENTER_LEFT">
  <children>
  
    <Text fx:id="rowIndex" styleClass="tasklist-rowindex" HBox.hgrow="NEVER" wrappingWidth="20.0" />
    
    <Circle fx:id="taskCheckMarkCircle" styleClass="tasklist-checkmarkcircle" radius="10" />
    <ImageView fitHeight="20.0" fitWidth="20.0" fx:id="taskCheckMarkImage" pickOnBounds="true" preserveRatio="true">
      <HBox.margin>
        <Insets right="10.0" />
      </HBox.margin>
    </ImageView>
    <VBox maxHeight="40.0" maxWidth="Infinity" minHeight="0.0" minWidth="-Infinity">
   		<children>
   	      <HBox maxHeight="40.0" maxWidth="Infinity" minHeight="10.0" minWidth="-Infinity">
   	        <children>
   	        	<Text fx:id="taskText" styleClass="tasklist-taskitem-label" HBox.hgrow="ALWAYS" />
			    <Text fx:id="taskTime" styleClass="tasklist-itemtime" HBox.hgrow="ALWAYS">
			      <HBox.margin>
			        <Insets left="10.0" />
			      </HBox.margin>
			    </Text>
   	        </children>
   	      </HBox>
   		  <HBox maxHeight="10.0" maxWidth="Infinity" minHeight="0.0" minWidth="-Infinity">
   		    <children>
   		      <Text fx:id="taskTagListText" styleClass="tasklist-itemtime" HBox.hgrow="ALWAYS" >
   		        <HBox.margin>
   		          <Insets top = "5.0" />
   		        </HBox.margin>
   		        </Text>
   		    </children>
   		  </HBox>
   		</children> 
    </VBox>
  </children>
  <padding>
    <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
  </padding>
</HBox>
```
###### \resources\ui\css\style.css
``` css

@font-face {
  font-family: "Roboto Thin";
  font-weight: 100;
  src: url("../fonts/Roboto-Thin.ttf");
}

@font-face {
  font-family: "Roboto Light";
  font-weight: 300;
  src: url("../fonts/Roboto-Light.ttf");
}

@font-face {
  font-family: "Roboto";
  src: url("../fonts/Roboto-Regular.ttf");
}

@font-face {
  font-family: "Roboto Medium";
  font-weight: 500;
  src: url("../fonts/Roboto-Medium.ttf");
}

* {
  text-color: #444444;
}

.main-window {
  color: text-color;
  -fx-background-color: #ffffff;
  -fx-font-family: "Roboto";
}

.view-title-text {
  -fx-font-size: 20px;
}

.scroll-pane, .split-pane, .scroll-pane > .viewport {
  -fx-background-insets: 0;
  -fx-padding: 0;
  -fx-background-color: #ffffff;
}

.font-100 {
  -fx-font-family: "Roboto Thin";
  -fx-font-weight: 100;
}

.font-300 {
  -fx-font-family: "Roboto Light";
  -fx-font-weight: 300;
}

.font-400 {
  -fx-font-family: "Roboto";
}

.font-500 {
  -fx-font-family: "Roboto Medium";
  -fx-font-weight: 500;
}

/* MENUBAR */

.menu-bar {
  -fx-border-width: 0 0 1 0;
  -fx-border-color: #eeeeee;
}

.menu-button {
  -fx-font-size: 12px;
}

/* HEADER */

VBox.header {
  -fx-background-color: #ffffff;
  -fx-border-width: 0 0 1 0;
  -fx-border-color: #eeeeee;
}

.header-text {
  -fx-font-size: 24px;
}

/* CONSOLE */

.text-field.console-input-textfield, .text-area.console-textarea {
  -fx-text-fill: text-color;
  -fx-border-width: 0px;
  -fx-border-radius: 0px;
  -fx-background-radius: 0px;
}

.text-field.console-input-textfield:focused, .text-area.console-textarea:focused {
  -fx-effect: none;
}

.text-field.console-input-textfield.invalid {
  -fx-text-fill: crimson;
}

.text-area.console-textarea {
  -fx-font-size: 14px;
  -fx-border-width: 1 0 1 0;
  -fx-border-color: #dddddd;
}

.text-area.console-textarea .content {
  -fx-background-color: #f9f9f9;
  -fx-background-radius: 0px;
}

/* TAG LIST */

.taglist-pane {
  -fx-background-color: #ffffff;
}

.taglist-title {
  -fx-font-size: 20px;
}

.taglist-link-text {
  -fx-font-size: 15px;
}

.taglist-item-text {
  -fx-font-size: 13px;
}

.taglist-item-bullet {
  -fx-fill-color: #999999;
}

/* TASK LIST */

.tasklist-pane {
  -fx-background-color: #ffffff;
}

.tasklist-title {
  -fx-font-size: 20px;
}

.tasklist-rowindex {
  -fx-font-size: 12px;
  -fx-fill: #999999;
}

.tasklist-dateitem-dateheader {
  -fx-font-size: 18px;
}

.tasklist-dateitem-datelabel {
  -fx-fill: #999999;
  -fx-font-size: 12px;
}

.tasklist-checkmarkcircle {
  -fx-fill: transparent;
  -fx-stroke: #dddddd;
}

.tasklist-itemtime {
  -fx-font-size: 11px;
  -fx-fill: #999999;
}

.tasklist-taskitem-label.completed {
  -fx-fill: #9BBAAD;
  -fx-strikethrough: true;
}

.tasklist-eventitem-label.completed {
  -fx-fill: #9BBAAD;
  -fx-strikethrough: true;
}

/* HELP VIEW */

.commandtext-name {
  -fx-font-size: 18px;
}

.commandtext-syntax {
  -fx-background-color: #aaaaaa;
  -fx-font-family: "Courier New", Courier, monospace;
}
```
###### \resources\ui\MainWindow.fxml
``` fxml
<VBox maxHeight="Infinity" maxWidth="Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="700" prefWidth="900" styleClass="font-400, main-window" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.todo.ui.MainWindow">
  <children>
    <MenuBar minHeight="30.0" maxHeight="30.0">
      <menus>
        <Menu mnemonicParsing="false" text="File">
          <items>
            <MenuItem fx:id="homeMenuItem" mnemonicParsing="false" onAction="#handleHome" text="Home" />
            <MenuItem fx:id="configMenuItem" mnemonicParsing="false" onAction="#handleConfig" text="Settings" />
            <MenuItem mnemonicParsing="false" onAction="#handleAlias" text="Aliases" />
            <SeparatorMenuItem />
            <MenuItem mnemonicParsing="false" onAction="#handleExit" text="Exit" />
          </items>
        </Menu>
        <Menu mnemonicParsing="false" text="Help">
          <items>
            <MenuItem fx:id="helpMenuItem" mnemonicParsing="false" onAction="#handleHelp" text="Help" />
          </items>
        </Menu>
      </menus>
    </MenuBar>
    
    <AnchorPane fx:id="headerPlaceholder" minHeight="90.0" maxHeight="90.0" VBox.vgrow="NEVER" />
    
    <AnchorPane fx:id="childrenPlaceholder" VBox.vgrow="ALWAYS">
      <Text layoutY="15.0" text="Loading..." textAlignment="CENTER" />
    </AnchorPane>
    
    <AnchorPane fx:id="consoleInputPlaceholder" minHeight="110.0" maxHeight="110.0" VBox.vgrow="NEVER" />
  </children>
  <stylesheets>
    <URL value="@css/bootstrap3.css" />
    <URL value="@css/style.css" />
  </stylesheets>
</VBox>
```
###### \resources\ui\views\ConfigView.fxml
``` fxml
<VBox maxHeight="Infinity" maxWidth="Infinity" minHeight="100" minWidth="100" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.todo.ui.views.ConfigView">
  <children>
    <HBox alignment="CENTER_LEFT">
      <children>
        <ImageView fitHeight="32.0" fitWidth="32.0" fx:id="configImageView" pickOnBounds="true" preserveRatio="true">
          <HBox.margin>
            <Insets right="10.0" />
          </HBox.margin>
        </ImageView>
        <Text styleClass="font-300, view-title-text" text="Settings" />
      </children>
      <VBox.margin>
        <Insets bottom="20.0" />
      </VBox.margin>
    </HBox>
    
    <Text fx:id="configInstructionsText">
      <VBox.margin>
        <Insets bottom="20.0" />
      </VBox.margin>
    </Text>

    <ScrollPane fitToHeight="true" fitToWidth="true" VBox.vgrow="ALWAYS">
      <content>
        <VBox styleClass="config-pane" fx:id="configsPlaceholder" VBox.vgrow="ALWAYS">
          <padding>
            <Insets bottom="20.0" />
          </padding>
        </VBox>
      </content>
    </ScrollPane>
  </children>

  <padding>
    <Insets top="20.0" left="20.0" bottom="20.0" right="20.0" />
  </padding>
</VBox>
```
###### \resources\ui\views\HelpView.fxml
``` fxml
<VBox maxHeight="Infinity" maxWidth="Infinity" minHeight="100" minWidth="100" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.todo.ui.views.HelpView">
  <children>
    <ScrollPane fitToHeight="true" fitToWidth="true" VBox.vgrow="ALWAYS">
      <content>
        <VBox styleClass="help-pane" fx:id="helpCommandsPlaceholder" VBox.vgrow="ALWAYS">
          <padding>
            <Insets left="20.0" top="20.0" right="20.0" bottom="20.0" />
          </padding>
        </VBox>
      </content>
    </ScrollPane>
  </children>
</VBox>
```
###### \resources\ui\views\IndexView.fxml
``` fxml
<VBox maxHeight="Infinity" maxWidth="Infinity" minHeight="100" minWidth="100" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.todo.ui.views.IndexView">
  <children>
    <SplitPane fx:id="splitPane" dividerPositions="0.3" VBox.vgrow="ALWAYS">
      <items>
        <ScrollPane minWidth="250.0" fitToHeight="true" fitToWidth="true">
          <content>
            <VBox fx:id="tagsPane" styleClass="taglist-pane" VBox.vgrow="ALWAYS" />
          </content>
        </ScrollPane>
        <ScrollPane minWidth="500.0" fitToHeight="true" fitToWidth="true">
          <content>
            <VBox fx:id="tasksPane" styleClass="tasklist-pane" VBox.vgrow="ALWAYS" />
          </content>
        </ScrollPane>
      </items>
    </SplitPane>
  </children>
</VBox>
```
